#### 📅 **Date**: 2025-03-12

#### 🔖 **Tags**: #SQL #InterviewQuestions

---

在資料庫中，**索引（Index）** 是一種**優化查詢效能的技術**，類似於書本的「目錄」，可以幫助資料庫更快地找到目標數據，而不需要掃描整個表格。

---

## **📍 1. 沒有索引時（全表掃描，Full Table Scan）**

當查詢**沒有使用索引**，資料庫**必須從第一行開始逐行掃描**，直到找到所有符合條件的記錄（類似 `O(n)` 的線性搜尋）。

🔹 **範例（假設有 100 萬筆記錄）**

```sql
SELECT * FROM Customers WHERE Name = 'John';
```

- **沒有索引時**，資料庫會執行 **全表掃描（Full Table Scan）**：
    1. 逐行讀取 `Customers` 資料表
    2. 檢查 `Name` 欄位是否為 `'John'`
    3. 如果找到，則回傳結果

👉 **缺點**：
- 當表格數據量變大時，查詢速度會變慢
- **時間複雜度：`O(n)`（線性搜尋）**
- **可能影響其他查詢效能（鎖表、佔用 I/O）**

---

## **📍 2. 使用索引時（B-Tree 加速查詢）**

🔹 **建立索引**

```sql
CREATE INDEX idx_name ON Customers (Name);
```

- **索引的作用**：建立一個排序過的 **B-Tree 結構**（或 Hash、Bitmap 索引），讓查詢可以**透過索引找到對應的記錄，而不需要全表掃描**。

🔹 **查詢時的索引機制**

```sql
SELECT * FROM Customers WHERE Name = 'John';
```

1. **透過 B-Tree 查找**，找到 `Name = 'John'` 的索引位置
2. 透過**索引指向原始數據的行（Row ID）**
3. **直接讀取所需的行**（不需逐行掃描）

👉 **優勢**： 
**時間複雜度降為 `O(log n)`**（B-Tree 查找）  
**避免全表掃描，提高查詢效能**  
✅ **更適合大數據量查詢（如百萬筆資料）**

---

## **📍 3. 索引的底層結構**

### **🔹 B-Tree（平衡樹）**

- 大多數**關聯式資料庫（MySQL、SQL Server、PostgreSQL）** 都使用 **B-Tree** 作為索引。
- **B-Tree 的特點**：
    1. **排序結構**：索引中的資料是**有序的**，可進行二分搜尋（Binary Search）
    2. **平衡性**：每個節點的高度相近，查詢時間複雜度約為 `O(log n)`
    3. **適用於範圍查詢**，如 `BETWEEN`、`LIKE 'A%'`

🔹 **B-Tree 索引查找過程**

mathematica

複製編輯

`索引結構：          M        /   \       C     T      / \   / \     A   F P   Z  查找 "P"： 1️⃣ 從根節點 "M" 開始 2️⃣ "P" > "M"，往右子樹走 3️⃣ 在 "T" 節點找到 "P"`

**查詢時間**：`O(log n)`

---

## **📍 4. 為什麼索引能加速搜尋？**

🔹 **對比不同查找方式**：

|查找方式|搜尋方式|時間複雜度|
|---|---|---|
|**全表掃描（Table Scan）**|逐行檢查每筆資料|`O(n)`|
|**索引查找（B-Tree）**|樹狀結構二分搜尋|`O(log n)`|
|**Hash 索引**|直接對應 Key-Value|`O(1)`（不適用範圍查詢）|

✔ **索引可以跳過不相關的資料行**，避免掃描整個資料表  
✔ **使用 B-Tree（平衡樹）可將搜尋時間降為 `O(log n)`**  
✔ **如果是 Hash 索引，查找時間可達 `O(1)`**（但不支援範圍查詢）

---

## **📍 5. 什麼情況下索引沒有效？**

**索引雖然可以加快查詢，但在某些情況下反而會影響效能！**

### **❌ 當索引無法使用時**

1️⃣ **`LIKE '%keyword'` 會失效**

sql

複製編輯

`SELECT * FROM Products WHERE Name LIKE '%Apple';`

- **原因**：索引是**從左到右排序**，前面有 `%` 時無法使用索引
- **解決方案**：使用 **全文索引（Full-Text Index）**

2️⃣ **小數據量時，索引反而影響效能**

- **如果表格只有幾百筆資料，使用索引可能會比全表掃描更慢**，因為資料庫還需要先讀取索引。

3️⃣ **索引過多，影響 `INSERT`、`UPDATE` 效能**

- 當有大量索引時，每次新增/修改資料都需要維護索引，可能降低寫入效能。

---

## **📍 6. 索引最佳化技巧**

### **✅ 使用覆蓋索引（Covering Index）**

讓索引直接**包含查詢的所有欄位**，避免回表（Lookup）。

sql

複製編輯

`CREATE INDEX idx_user ON Users (Name, Age);`

這樣：

sql

複製編輯

`SELECT Name, Age FROM Users WHERE Name = 'John';`

✅ **可以直接從索引獲取資料，不需回原始表格**  
✅ **提升查詢效能**

---

### **✅ 使用 Composite Index（複合索引）**

如果經常用 **多個欄位** 查詢，如：

sql

複製編輯

`SELECT * FROM Orders WHERE CustomerID = 5 AND OrderDate = '2024-03-12';`

可以建立：

sql

複製編輯

`CREATE INDEX idx_orders ON Orders (CustomerID, OrderDate);`

✅ **加快篩選條件組合查詢**

---

### **✅ 避免索引失效**

❌ 錯誤：

sql

複製編輯

`SELECT * FROM Products WHERE price + 10 = 100;`

✅ 正確：

sql

複製編輯

`SELECT * FROM Products WHERE price = 90;`

✔ **索引欄位不能進行計算，否則會導致索引失效！**

---

## **📌 總結**

1️⃣ **索引是「資料表的目錄」，加快查詢速度**，避免全表掃描。  
2️⃣ **使用 B-Tree 讓查詢從 `O(n)` 降到 `O(log n)`**，提升效能。  
3️⃣ **Hash 索引速度更快 (`O(1)`)，但不支援範圍查詢。**  
4️⃣ **索引過多會影響 `INSERT`、`UPDATE`**，需權衡效能。  
5️⃣ **避免索引失效（避免函數計算、LIKE `%keyword`）**，可使用**全文索引（Full-Text Index）**。

---

🔥 **面試技巧**： 如果面試官問 **「為什麼索引能加速查詢？」** ✅ **回答**：「因為索引使用 **B-Tree** 結構來組織數據，使查找時間從 `O(n)` 降為 `O(log n)`，可以快速找到符合條件的記錄，而不需要全表掃描。」
