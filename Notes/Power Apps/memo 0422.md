# Pre-Operation 插件實作詳解

Pre-Operation 插件會在資料庫交易完成前執行，可直接修改傳入的資料。讓我詳細說明如何實作一個理想的 Pre-Operation 插件來同步 Incident Type 欄位：

## 推薦的 Pre-Operation 插件寫法

```csharp
using System;
using Microsoft.Xrm.Sdk;
using Twtoto.ASManagement.Core;

namespace Twtoto.ASManagement.IncidentPlugins
{
    public class IncidentTypeSync : PluginHandler, IPlugin
    {
        protected override string PluginName => "IncidentTypeSync";
        protected override string[] RequiredInputParameters => new string[] { "Target" };
        public override LogLevel CurrentLogLevel => LogLevel.Debug;

        public void Execute(IServiceProvider serviceProvider)
        {
            Run(serviceProvider);
        }

        protected override void ExecuteCore()
        {
            Log(LogLevel.Debug, "進入 IncidentTypeSync ExecuteCore 方法 (Pre-Operation)。");

            // 1. 檢查是否為 Update 訊息
            if (_context.MessageName.ToLower() != "update")
            {
                Log(LogLevel.Debug, $"非 Update 訊息 ({_context.MessageName})，插件結束。");
                return;
            }

            // 2. 驗證實體類型
            if (_context.PrimaryEntityName.ToLower() != "incident")
            {
                Log(LogLevel.Debug, $"非 Incident 實體 ({_context.PrimaryEntityName})，插件結束。");
                return;
            }

            // 3. 取得 Target Entity
            Entity target = null;
            if (_context.InputParameters.Contains("Target") && _context.InputParameters["Target"] is Entity)
            {
                target = (Entity)_context.InputParameters["Target"];
                Log(LogLevel.Debug, "成功取得 Target Entity。");
            }
            else
            {
                Log(LogLevel.Error, "無法取得 Target Entity 或 Target 非 Entity 型別。");
                throw new InvalidPluginExecutionException("無法取得有效的 Target Entity。");
            }

            // 4. 防止插件無限循環執行
            if (_context.Depth > 1)
            {
                Log(LogLevel.Warning, $"插件執行深度已達 {_context.Depth}，為避免無限迴圈，提前結束。");
                return;
            }

            // 5. 檢查觸發更新的欄位是否包含我們關心的 'twtoto_incidenttype1'
            if (target.Contains("twtoto_incidenttype1"))
            {
                Log(LogLevel.Info, "偵測到 twtoto_incidenttype1 欄位變更，開始同步處理...");

                try
                {
                    // 6. 從 Target 取得 'twtoto_incidenttype1' 的值
                    EntityReference sourceIncidentTypeRef = target.GetAttributeValue<EntityReference>("twtoto_incidenttype1");

                    // 記錄欄位值
                    if (sourceIncidentTypeRef != null)
                    {
                        Log(LogLevel.Debug, $"來源欄位值: Id={sourceIncidentTypeRef.Id}, Name={sourceIncidentTypeRef.Name}, LogicalName={sourceIncidentTypeRef.LogicalName}");
                    }
                    else
                    {
                        Log(LogLevel.Debug, "來源欄位值為 null。");
                    }

                    // 7. 檢查目標欄位是否需要更新
                    bool needsUpdate = false;
                    
                    // 如果目標欄位不存在於 Target 中，需要進行一次查詢取得當前值
                    if (!target.Contains("msdyn_incidenttype") && _context.PreEntityImages.Contains("PreImage"))
                    {
                        Entity preImage = (Entity)_context.PreEntityImages["PreImage"];
                        if (preImage.Contains("msdyn_incidenttype"))
                        {
                            EntityReference currentTargetRef = preImage.GetAttributeValue<EntityReference>("msdyn_incidenttype");
                            
                            if (sourceIncidentTypeRef == null && currentTargetRef != null)
                            {
                                needsUpdate = true;
                            }
                            else if (sourceIncidentTypeRef != null && currentTargetRef == null)
                            {
                                needsUpdate = true;
                            }
                            else if (sourceIncidentTypeRef != null && currentTargetRef != null && 
                                    sourceIncidentTypeRef.Id != currentTargetRef.Id)
                            {
                                needsUpdate = true;
                            }
                        }
                        else
                        {
                            // 如果 PreImage 中沒有目標欄位，則假設需要更新
                            needsUpdate = true;
                        }
                    }
                    else
                    {
                        // 如果沒有 PreImage 或目標欄位已在 Target 中，直接更新
                        needsUpdate = true;
                    }

                    // 8. 執行同步
                    if (needsUpdate)
                    {
                        Log(LogLevel.Info, "開始同步欄位值...");
                        target["msdyn_incidenttype"] = sourceIncidentTypeRef;
                        Log(LogLevel.Info, "同步完成。");
                    }
                    else
                    {
                        Log(LogLevel.Info, "來源與目標欄位值已一致，無需更新。");
                    }
                }
                catch (Exception ex)
                {
                    Log(LogLevel.Error, $"同步 Incident Type 時發生錯誤: {ex.ToString()}");
                    throw new InvalidPluginExecutionException("同步 Incident Type 時發生錯誤，請聯繫管理員。", ex);
                }
            }
            else
            {
                Log(LogLevel.Debug, "此次更新未修改 twtoto_incidenttype1 欄位，無需執行同步。");
            }

            Log(LogLevel.Debug, "離開 IncidentTypeSync ExecuteCore 方法 (Pre-Operation)。");
        }
    }
}
```

## 關鍵實作要點說明

1. **插件註冊設定**：
    
    - 註冊為 Pre-Operation 階段 (Stage 20)
    - 實體：incident
    - 訊息：Update
    - 過濾屬性：twtoto_incidenttype1
    - 設置 PreEntityImage，包含 msdyn_incidenttype 欄位
2. **執行流程與檢查**：
    
    - 檢查訊息類型和實體類型
    - 確保 Target 存在並為 Entity 類型
    - 防止無限循環 (Depth > 1)
    - 檢查是否包含目標欄位
3. **PreEntityImage 的使用**：
    
    - 使用 PreEntityImage 獲取欄位的原始值
    - 這可以避免不必要的資料庫查詢
4. **優化更新邏輯**：
    
    - 只在必要時（來源和目標值不同）進行更新
    - 處理 null 值的情況
5. **完整的錯誤處理與日誌記錄**：
    
    - 記錄每個關鍵步驟
    - 特別標記錯誤和警告
    - 拋出適當的異常，提供充分訊息

## 註冊插件的步驟

1. 打開 Plugin Registration Tool
2. 選擇 Register > Register New Step
3. 設定：
    - Message: Update
    - Primary Entity: incident
    - Event Pipeline Stage of Execution: Pre-Operation
    - Execution Mode: 同步 (Synchronous)
    - Filtering Attributes: twtoto_incidenttype1
4. 註冊 Pre-Entity Image:
    - 名稱：PreImage
    - 包含欄位：msdyn_incidenttype (至少)

這種實作方式在確保數據一致性的同時，最大限度地提高了效率，並且擁有完整的錯誤處理機制與防止循環執行的保護措施。

---

好的，這段 `PluginHandler` 程式碼是一個設計得相當不錯的 **抽象基礎類別 (Abstract Base Class)**，它的主要目的是作為一個**可重用的模板**，讓你在開發新的 Dynamics 365 Plugin 時可以更方便、更標準化。

透過繼承這個 `PluginHandler`，你的具體 Plugin 類別（像是 `CopyValueToIncidentTypePlugin`）就可以專注在實現核心的業務邏輯 (`ExecuteCore` 方法)，而不需要重複編寫許多通用的設定、初始化、記錄和錯誤處理程式碼。

**主要功能和設計分析：**

1. **抽象類別 (`abstract class PluginHandler`)**:
    
    - 表明這個類別不能被直接實例化，它必須被其他具體的 Plugin 類別繼承。
2. **日誌記錄 (`LogLevel` Enum, `Log`, `LogInfo`, etc.)**:
    
    - 定義了 `Debug`, `Info`, `Warning`, `Error` 四個日誌等級。
    - 提供了一個 `CurrentLogLevel` 屬性（預設為 `Info`），讓繼承的類別可以控制要記錄哪些等級以上的訊息。
    - 核心的 `Log` 方法會根據 `CurrentLogLevel` 過濾訊息，並使用 Dynamics 365 提供的 `ITracingService` (`_tracer`) 來實際寫入日誌（這些日誌可以在 Plugin Trace Log 中查看）。
    - 提供了方便的輔助方法 `LogInfo`, `LogDebug` 等。
    - 包含了自動截斷過長訊息的處理。
3. **強制/可選設定 (`PluginName`, `RequiredInputParameters`, `CurrentLogLevel`)**:
    
    - `PluginName` (abstract): 強制繼承的類別必須提供一個名稱，主要用於日誌輸出，方便識別是哪個 Plugin 在執行。
    - `RequiredInputParameters` (virtual): 允許繼承的類別指定哪些輸入參數是必需的（例如 `"Target"`）。提供了預設的空陣列，並有對應的驗證邏輯。
    - `CurrentLogLevel` (virtual): 允許繼承的類別覆寫預設的日誌記錄等級。
4. **核心服務初始化 (`Init`, `_context`, `_service`, `_tracer`)**:
    
    - `Init` 方法負責從 `IServiceProvider` 中取得 Plugin 開發中最常用的三個服務：
        - `_context` (IPluginExecutionContext): 包含觸發事件的所有上下文資訊。
        - `_service` (IOrganizationService): 用於執行 CRUD (建立、讀取、更新、刪除) 等資料庫操作。這裡透過 `serviceFactory.CreateOrganizationService(_context.UserId)` 建立，表示後續的操作會以觸發事件的使用者身份執行。
        - `_tracer` (ITracingService): 用於寫入追蹤日誌。
    - 這些核心服務被儲存為類別成員 (`public` 或 `private`)，方便在 `Run` 方法和繼承的類別中使用（雖然 `_context` 和 `_service` 設為 `public` 比較少見，通常會設為 `protected`，但功能上可行）。
5. **標準化的執行流程 (`Run`)**:
    
    - 這是整個模板的核心，由具體 Plugin 的 `Execute` 方法呼叫。
    - 它定義了一個標準的執行順序：
        1. `Init()`: 初始化服務。
        2. 記錄開始訊息和基本 Context 資訊。
        3. `ValidateInputParameters()`: 驗證輸入參數（基於 `RequiredInputParameters` 和可選的 `ValidateOther`）。如果驗證失敗，記錄錯誤並拋出 `InvalidPluginExecutionException`。
        4. **`ExecuteCore()`**: 在 `try-catch` 保護下呼叫**抽象方法**。這是**必須由繼承類別實現**的部分，包含真正的業務邏輯。如果 `ExecuteCore` 內部發生錯誤，會被捕捉並包裝成 `InvalidPluginExecutionException` 再次拋出。
        5. **錯誤處理**: 外層的 `try-catch` 處理所有可能的例外狀況，記錄詳細的錯誤訊息（包括 Inner Exception）到 Trace Log。
        6. `finally`: 無論成功或失敗，都記錄結束訊息。
    - 這種結構確保了基本的日誌記錄、參數驗證和錯誤處理都以一致的方式進行。
6. **核心業務邏輯佔位符 (`ExecuteCore`)**:
    
    - `protected abstract void ExecuteCore();` 定義了一個抽象方法。這表示任何繼承 `PluginHandler` 的類別都**必須**提供這個方法的具體實現。開發者只需要專注於在這個方法裡編寫業務邏輯。
7. **輸入參數驗證 (`ValidateInputParameters`, `ValidateRequiredInputParameters`, `ValidateOther`)**:
    
    - 提供了一個框架來驗證傳入 Plugin 的參數是否符合預期。
    - `ValidateRequiredInputParameters` 會自動檢查 `RequiredInputParameters` 陣列中列出的參數是否存在於 `_context.InputParameters` 中。
    - `ValidateOther` 提供了一個擴展點，允許繼承的類別加入更複雜的自訂驗證邏輯。
8. **輔助方法 (Helpers)**:
    
    - `GetInputParameter<T>()`: 一個泛型方法，用於安全地從 `_context.InputParameters` 中按名稱獲取指定型別的參數，並處理了參數不存在、為 null 或型別不匹配的情況，同時記錄了相關訊息。
    - **`GetTargetEntity<T>()`**: 這個方法直接回答了你之前的問題！它是一個更方便的方法，**內部直接呼叫 `GetInputParameter<T>("Target")`**，專門用來獲取名為 "Target" 的輸入參數（通常就是觸發事件的 Entity）。
    - `ExistRequiredInputParameter()`: 內部用於驗證必需參數的輔助函數。
    - `GetPreImage()`, `GetPostImage()`: 方便地獲取 Pre/Post Entity Image，並處理了 Image 不存在的情況。
    - `SetOutputParameter()`: 用於設定 Plugin 的輸出參數（主要用於 Custom Action 或某些特定訊息）。

**總結：**

這段 `PluginHandler` 程式碼是一個非常實用的 Dynamics 365 Plugin 開發基礎框架。它透過提供標準化的初始化、執行流程、日誌記錄、錯誤處理和參數驗證，大大簡化了具體 Plugin 的開發工作，提高了程式碼的可讀性、一致性和健壯性。開發者只需要繼承它，實現 `PluginName` 和 `ExecuteCore`，並根據需要覆寫 `RequiredInputParameters` 或 `CurrentLogLevel`，就可以快速開發出功能完整的 Plugin。

---

Okay, let's build this Plugin using your `PluginHandler` base class. Based on our previous discussion, we'll implement this using the **Post-operation** stage, as it's generally more suitable for reacting after the Work Order status change is confirmed.

**Assumptions (需要你確認或替換成實際值):**

- 工單上指向案例的欄位是: `msdyn_servicerequest`
- 工單狀態子類別 (msdyn_substatus) 的值:
    - 自動結案: `10001` (請替換為實際值)
    - 審核結案: `10002` (請替換為實際值)
- 案例狀態 (statecode) 的值:
    - 已解決 (Resolved): `1`
- 案例狀態原因 (statuscode) 的值:
    - 問題已解決 (Problem Solved): `5` (請替換為實際值)
- 案例類型欄位名稱: `casetypecode` (如果是其他欄位請替換)
- 案例類型 "諮詢" 的值: `20001` (請替換為實際值)
- 案例使用的 BPF 實例實體邏輯名稱: `[你的BPF實例邏輯名稱]` (例如 `incidentprocess` 或 `new_mycasebpfprocesss` 等，需要去系統確認)
- 案例 BPF 中 "結案" 階段的 Stage ID (GUID): `AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE` (**必須替換為實際的 Stage ID GUID**)
- BPF 實例中代表完成狀態的 `statecode` 和 `statuscode` 值 (通常 statecode=1, statuscode=2，但需確認)

**Plugin 程式碼 (C#):**

C#

```
using System;
using System.Linq;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Query;
using Twtoto.ASManagement.Core; // 你的 PluginHandler 基礎類別

namespace Twtoto.ASManagement.IncidentPlugins.Plugins
{
    // 使用我們建議的名稱
    public class IncidentAutoResolutionPlugin : PluginHandler, IPlugin
    {
        // --- 設定值 (請替換為你的環境中的實際值) ---
        private const int WO_SUBSTATUS_AUTO_CLOSED = 10001; // 工單子狀態: 自動結案 的值
        private const int WO_SUBSTATUS_REVIEW_CLOSED = 10002; // 工單子狀態: 審核結案 的值
        private readonly int[] ClosedWoSubstatuses = { WO_SUBSTATUS_AUTO_CLOSED, WO_SUBSTATUS_REVIEW_CLOSED };

        private const int CASE_STATECODE_RESOLVED = 1; // 案例狀態: 已解決 的值
        private const int CASE_STATUSCODE_PROBLEM_SOLVED = 5; // 案例狀態原因: 問題已解決 的值

        private const string CASE_TYPE_FIELD = "casetypecode"; // 案例類型欄位名稱
        private const int CASE_TYPE_CONSULTING = 20001; // 案例類型: 諮詢 的值

        private const string CASE_LOOKUP_ON_WO = "msdyn_servicerequest"; // 工單上指向案例的欄位名稱

        // --- BPF 相關設定 (!!! 非常重要，必須替換 !!!) ---
        // 你的案例 BPF 實例實體的"邏輯名稱" (例如 "incidentprocess", "new_bpf_...")
        private const string CASE_BPF_INSTANCE_ENTITY_NAME = "incidentprocess"; // <--- 替換!
        // 你的案例 BPF 中"結案"階段的 Stage ID (GUID)
        private readonly Guid BPF_STAGE_ID_CLOSED = new Guid("AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE"); // <--- 替換!
        // 你的案例 BPF 實例的"完成"狀態值 (通常是 1)
        private const int BPF_INSTANCE_STATECODE_COMPLETED = 1;
        // 你的案例 BPF 實例的"完成"狀態原因值 (例如 2 代表 Finished)
        private const int BPF_INSTANCE_STATUSCODE_FINISHED = 2;
        // BPF 實例上指向對應案例的欄位名稱 (通常是 "bpf_incidentid")
        private const string BPF_CASE_LOOKUP_FIELD = "bpf_incidentid"; // <--- 如果不同請替換!
        // Process Stage 實體的邏輯名稱 (通常是 "processstage")
        private const string PROCESS_STAGE_ENTITY_NAME = "processstage";


        // --- PluginHandler 實作 ---
        protected override string PluginName => "IncidentAutoResolutionPlugin";
        public override LogLevel CurrentLogLevel => LogLevel.Debug; // 方便除錯，上線後可改回 Info
        // Post-Operation 通常需要 PostImage 來取得更新後的值
        protected override string[] RequiredInputParameters => new string[] { "Target" };

        public void Execute(IServiceProvider serviceProvider)
        {
            Run(serviceProvider); // 呼叫基底類別的 Run 方法
        }

        // --- 核心邏輯 ---
        protected override void ExecuteCore()
        {
            Log(LogLevel.Debug, "進入 IncidentAutoResolutionPlugin ExecuteCore (Post-Operation)。");

            // 1. 基本驗證 (基底類別已處理 Target 存在)
            if (_context.MessageName.ToLower() != "update")
            {
                Log(LogLevel.Debug, $"非 Update 訊息 ({_context.MessageName})，插件結束。");
                return;
            }
            if (_context.PrimaryEntityName.ToLower() != "msdyn_workorder")
            {
                 Log(LogLevel.Debug, $"非 Work Order 實體 ({_context.PrimaryEntityName})，插件結束。");
                 return;
            }

            // 2. 深度檢查 (防止無限循環)
            if (_context.Depth > 1)
            {
                Log(LogLevel.Warning, $"插件執行深度已達 {_context.Depth}，為避免無限迴圈，提前結束。");
                return;
            }

            // 3. 取得 Post Image (假設註冊時命名為 "PostImage")
            //    需要包含 msdyn_substatus 和 CASE_LOOKUP_ON_WO 欄位
            Entity postImage = _context.PostEntityImages.Contains("PostImage") ? _context.PostEntityImages["PostImage"] : null;
            if (postImage == null)
            {
                Log(LogLevel.Warning, "無法取得名為 'PostImage' 的 PostEntityImage，請檢查 Plugin Step 註冊設定。插件結束。");
                // 或者嘗試從 Target 取得，但不建議在 Post-Op 依賴 Target
                // Entity target = GetTargetEntity<Entity>();
                // if (!target.Contains("msdyn_substatus")) return; // 如果 Target 裡沒有子狀態，也無法判斷
                return;
            }

            // 4. 檢查觸發工單的狀態是否為結案狀態之一
            OptionSetValue woSubStatus = postImage.GetAttributeValue<OptionSetValue>("msdyn_substatus");
            if (woSubStatus == null || !ClosedWoSubstatuses.Contains(woSubStatus.Value))
            {
                Log(LogLevel.Debug, $"工單狀態子類別 ({woSubStatus?.Value}) 不是目標結案狀態，無需處理。");
                return; // 不是目標結案狀態，直接結束
            }

            // 5. 取得父案例的 EntityReference
            EntityReference parentCaseRef = postImage.GetAttributeValue<EntityReference>(CASE_LOOKUP_ON_WO);
            if (parentCaseRef == null)
            {
                Log(LogLevel.Info, "此工單沒有關聯的父案例，無需處理。");
                return; // 沒有父案例，直接結束
            }
            Guid parentCaseId = parentCaseRef.Id;
            Log(LogLevel.Info, $"觸發工單 { _context.PrimaryEntityId} 已結案，開始檢查父案例 {parentCaseId} 的所有工單狀態。");

            // 6. 查詢與該案例關聯的所有工單
            QueryExpression query = new QueryExpression("msdyn_workorder");
            query.ColumnSet = new ColumnSet("msdyn_substatus"); // 只需要檢查狀態子類別
            query.Criteria.AddCondition(CASE_LOOKUP_ON_WO, ConditionOperator.Equal, parentCaseId);

            EntityCollection relatedWOs = _service.RetrieveMultiple(query);
            Log(LogLevel.Debug, $"找到 {relatedWOs.Entities.Count} 個與案例關聯的工單。");

            // 7. 檢查是否所有工單都已是結案狀態
            bool allWorkOrdersClosed = true;
            foreach (Entity wo in relatedWOs.Entities)
            {
                OptionSetValue currentWoSubStatus = wo.GetAttributeValue<OptionSetValue>("msdyn_substatus");
                if (currentWoSubStatus == null || !ClosedWoSubstatuses.Contains(currentWoSubStatus.Value))
                {
                    // 只要找到一個不是結案狀態的工單，就設定 flag 並跳出迴圈
                    allWorkOrdersClosed = false;
                    Log(LogLevel.Info, $"找到未結案工單 {wo.Id} (狀態: {currentWoSubStatus?.Value})，案例不自動結案。");
                    break;
                }
            }

            // 8. 如果所有工單都已結案，則執行案例結案動作
            if (allWorkOrdersClosed)
            {
                Log(LogLevel.Info, $"案例 {parentCaseId} 的所有關聯工單均已結案，準備自動結案案例。");

                try
                {
                    // (a) 取得案例資料，檢查是否需要結案 (避免重複執行或結案諮詢類型)
                    Log(LogLevel.Debug, "檢查案例當前狀態和類型...");
                    Entity currentCase = _service.Retrieve("incident", parentCaseId,
                        new ColumnSet("statecode", CASE_TYPE_FIELD, "processid", "stageid")); // processid 和 stageid 可能對 BPF 有用

                    OptionSetValue currentStateCode = currentCase.GetAttributeValue<OptionSetValue>("statecode");
                    OptionSetValue currentCaseType = currentCase.GetAttributeValue<OptionSetValue>(CASE_TYPE_FIELD);

                    if (currentStateCode != null && currentStateCode.Value == CASE_STATECODE_RESOLVED)
                    {
                        Log(LogLevel.Info, $"案例 {parentCaseId} 狀態已經是 Resolved，無需重複結案。");
                        return;
                    }
                    if (currentCaseType != null && currentCaseType.Value == CASE_TYPE_CONSULTING)
                    {
                        Log(LogLevel.Info, $"案例 {parentCaseId} 是諮詢類型，不自動結案。");
                        return;
                    }
                    Log(LogLevel.Debug, "案例狀態和類型檢查通過。");

                    // (b) 更新案例狀態和狀態原因
                    Log(LogLevel.Info, $"準備更新案例 {parentCaseId} 狀態為 Resolved/Problem Solved...");
                    Entity caseToUpdate = new Entity("incident", parentCaseId);
                    caseToUpdate["statecode"] = new OptionSetValue(CASE_STATECODE_RESOLVED);
                    caseToUpdate["statuscode"] = new OptionSetValue(CASE_STATUSCODE_PROBLEM_SOLVED);
                    _service.Update(caseToUpdate);
                    Log(LogLevel.Info, $"成功更新案例 {parentCaseId} 狀態。");

                    // (c) 更新 BPF 階段到 "結案" 並完成 (較複雜部分)
                    Log(LogLevel.Info, $"準備更新案例 {parentCaseId} 的 BPF 階段...");
                    // 查詢與案例關聯的 BPF 實例記錄
                    QueryExpression bpfQuery = new QueryExpression(CASE_BPF_INSTANCE_ENTITY_NAME);
                    bpfQuery.ColumnSet = new ColumnSet("activityid", "activestageid", "statecode", "statuscode"); // activityid 是主鍵
                    bpfQuery.Criteria.AddCondition(BPF_CASE_LOOKUP_FIELD, ConditionOperator.Equal, parentCaseId);
                    // 可能有多個 BPF 實例，理論上應該只有一個是 Active 的，或者取最新的
                    bpfQuery.Orders.Add(new OrderExpression("createdon", OrderType.Descending));
                    bpfQuery.TopCount = 1;

                    EntityCollection bpfInstances = _service.RetrieveMultiple(bpfQuery);

                    if (bpfInstances.Entities.Any())
                    {
                        Entity activeBpfInstance = bpfInstances.Entities[0];
                        Guid bpfInstanceId = activeBpfInstance.Id;
                        Log(LogLevel.Debug, $"找到 Active BPF 實例: {bpfInstanceId}");

                        // 檢查是否需要更新 BPF 階段和狀態
                        EntityReference currentStageRef = activeBpfInstance.GetAttributeValue<EntityReference>("activestageid");
                        OptionSetValue currentBpfStateCode = activeBpfInstance.GetAttributeValue<OptionSetValue>("statecode");

                        bool bpfNeedsUpdate = true;
                        // 如果當前階段已是結案階段且 BPF 狀態已完成，則可能無需更新
                        if (currentStageRef != null && currentStageRef.Id == BPF_STAGE_ID_CLOSED &&
                            currentBpfStateCode != null && currentBpfStateCode.Value == BPF_INSTANCE_STATECODE_COMPLETED)
                        {
                              bpfNeedsUpdate = false;
                              Log(LogLevel.Info, "BPF 階段已是結案且狀態已完成，無需更新 BPF。");
                        }

                        if (bpfNeedsUpdate)
                        {
                            Entity bpfInstanceToUpdate = new Entity(CASE_BPF_INSTANCE_ENTITY_NAME, bpfInstanceId);
                            // 設定 Active Stage 為結案階段
                            bpfInstanceToUpdate["activestageid"] = new EntityReference(PROCESS_STAGE_ENTITY_NAME, BPF_STAGE_ID_CLOSED);
                            // 設定 BPF 狀態為完成/結束
                            bpfInstanceToUpdate["statecode"] = new OptionSetValue(BPF_INSTANCE_STATECODE_COMPLETED);
                            bpfInstanceToUpdate["statuscode"] = new OptionSetValue(BPF_INSTANCE_STATUSCODE_FINISHED);
                            // BPF 實例的 'traversedpath' 欄位也可能需要更新，包含結案階段ID，但通常平台會自動處理一部分
                            // bpfInstanceToUpdate["traversedpath"] = ... (較複雜，通常省略)

                            Log(LogLevel.Debug, $"準備更新 BPF 實例 {bpfInstanceId}，設定 Active Stage ID 為 {BPF_STAGE_ID_CLOSED}，狀態為 Completed/Finished...");
                            _service.Update(bpfInstanceToUpdate);
                            Log(LogLevel.Info, $"成功更新 BPF 實例 {bpfInstanceId}。");
                        }
                    }
                    else
                    {
                        Log(LogLevel.Warning, $"案例 {parentCaseId} 找不到關聯的 BPF 實例 ({CASE_BPF_INSTANCE_ENTITY_NAME})。無法更新 BPF 階段。");
                    }
                }
                catch (Exception ex)
                {
                    Log(LogLevel.Error, $"自動結案案例 {parentCaseId} 或更新 BPF 時發生錯誤: {ex.ToString()}");
                    // 即使這裡出錯，工單已經結案，案例狀態更新也可能已部分成功
                    // 這裡不建議拋出例外，避免影響其他流程，以 Log 為主
                    // throw new InvalidPluginExecutionException($"自動結案案例時出錯: {ex.Message}", ex);
                }
            }
            else
            {
                Log(LogLevel.Info, $"案例 {parentCaseId} 尚有未結案的工單，不執行自動結案。");
            }

            Log(LogLevel.Debug, "離開 IncidentAutoResolutionPlugin ExecuteCore (Post-Operation)。");
        }
    }
}
```

**程式碼說明與注意事項：**

1. **常數設定：** 將所有需要根據你的環境修改的值（選項集數值、欄位名稱、階段 ID）都定義為常數，放在開頭，方便修改。**你必須將這些常數的值替換成你系統中的實際值！**
2. **繼承與基礎方法：** 繼承自 `PluginHandler`，並在 `Execute` 中呼叫 `Run()`。
3. **Post-operation 邏輯：**
    - 檢查 Message, Entity, Depth。
    - **使用 PostEntityImage:** 程式碼現在依賴名為 "PostImage" 的 PostEntityImage 來獲取工單更新後的值 (`msdyn_substatus`, `msdyn_servicerequest`)。你需要在註冊此 Plugin Step 時**務必註冊**這個 PostImage，並**包含這兩個欄位**。
    - 檢查觸發工單是否為目標結案狀態。
    - 檢查是否有父案例。
    - `RetrieveMultiple` 查詢所有相關工單。
    - 遍歷檢查所有工單是否都已結案。
    - 如果都結案了：
        - `Retrieve` 獲取案例當前狀態和類型，進行排除判斷。
        - `Update` 更新案例的 `statecode` 和 `statuscode`。
        - 查詢對應的 BPF 實例。
        - 如果找到 BPF 實例且需要更新，則 `Update` BPF 實例的 `activestageid`, `statecode`, `statuscode`。
4. **BPF 更新的複雜性：**
    - 你需要**準確知道**你的案例 BPF 實例實體的**邏輯名稱** (`CASE_BPF_INSTANCE_ENTITY_NAME`)。
    - 你需要**準確知道**結案階段的 **Stage ID (GUID)** (`BPF_STAGE_ID_CLOSED`)。
    - 你需要**準確知道** BPF 實例上代表完成的 **statecode 和 statuscode 的值**。
    - BPF 實例上記錄關聯案例的欄位通常是 `bpf_[案例實體邏輯名稱]id`，例如 `bpf_incidentid`，但也可能不同，需要確認 (`BPF_CASE_LOOKUP_FIELD`)。
    - 更新 `activestageid` 時需要提供 `EntityReference`，其目標實體是 Process Stage (`processstage`)。
5. **錯誤處理：** 在結案案例和更新 BPF 的部分加入了 `try-catch`，主要以記錄錯誤為主，避免因為更新 BPF 失敗等原因導致整個工單更新失敗（因為主操作已在 Post-operation 之前完成）。
6. **註冊步驟：**
    - **Message:** Update
    - **Primary Entity:** msdyn_workorder
    - **Filtering Attributes:** msdyn_substatus
    - **Stage:** Post-operation
    - **Execution Mode:** Synchronous (建議，確保即時性) 或 Asynchronous
    - **Post Image:** 註冊一個名為 "PostImage" 的 Post Entity Image，**必須包含** `msdyn_substatus` 和 `msdyn_servicerequest` (或你實際使用的案例查閱欄位) 這兩個欄位。

**在部署之前，請務必仔細檢查並替換掉所有標記為 `<--- 替換!` 的常數值，並確認欄位邏輯名稱是否符合你的環境。**

---

好的，這就提供使用你提供的 `PluginHandler` 基礎類別來實作這個需求的 Plugin (C#) 程式碼範例。

**重要提醒：**

1. **替換佔位符：** 程式碼中包含了許多 **必須被替換** 的佔位符（例如 `GUID_HERE`, `OPTIONSSET_VALUE_HERE`, `LOGICAL_NAME_HERE`）。你需要根據你的實際環境找出正確的值來替換它們。
2. **註冊設定：** 這個 Plugin 需要被正確地註冊才能運作（後面會說明）。
3. **錯誤處理：** 範例中包含了基本的錯誤處理和記錄，你可以根據需要調整。
4. **執行階段：** 範例是基於我們建議的 `Post-operation` (運作後) 階段。

C#

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Query;
using Twtoto.ASManagement.Core; // 你的 PluginHandler 基礎類別

namespace Twtoto.ASManagement.IncidentPlugins.Plugins
{
    public class IncidentAutoResolutionPlugin : PluginHandler, IPlugin
    {
        // --- !! 配置值 !! --- ( !!! 必須根據你的環境替換以下所有 GUID_HERE, OPTIONSSET_VALUE_HERE, LOGICAL_NAME_HERE !!! )

        // --- 工單子狀態 (msdyn_workordersubstatus) ---
        // "自動結案" 記錄的 GUID
        private readonly Guid WO_SUBSTATUS_AUTO_CLOSED_GUID = new Guid("GUID_HERE_FOR_AUTO_CLOSED");
        // "審核結案" 記錄的 GUID
        private readonly Guid WO_SUBSTATUS_REVIEW_CLOSED_GUID = new Guid("GUID_HERE_FOR_REVIEW_CLOSED");
        // 將結案狀態的 GUID 放入 List 或 Array，方便檢查
        private List<Guid> ClosedWoSubstatusGuids => new List<Guid> { WO_SUBSTATUS_AUTO_CLOSED_GUID, WO_SUBSTATUS_REVIEW_CLOSED_GUID };

        // --- 案例 (incident) ---
        // "已解決 (Resolved)" 狀態的 statecode 值 (通常是 1)
        private const int CASE_STATECODE_RESOLVED = 1;
        // "問題已解決 (Problem Solved)" 狀態原因的 statuscode 值 (例如 5)
        private const int CASE_STATUSCODE_PROBLEM_SOLVED = OPTIONSSET_VALUE_HERE_FOR_PROBLEM_SOLVED;
        // 案例類型欄位的邏輯名稱 (例如 "casetypecode")
        private const string CASE_TYPE_FIELD = "LOGICAL_NAME_HERE_FOR_CASETYPE";
        // "諮詢" 類型的選項值
        private const int CASE_TYPE_CONSULTING = OPTIONSSET_VALUE_HERE_FOR_CONSULTING;
        // 工單上指向案例的查閱欄位邏輯名稱 (通常是 "msdyn_servicerequest")
        private const string CASE_LOOKUP_ON_WO = "msdyn_servicerequest";

        // --- 案例業務流程 (BPF) ---
        // 案例所使用的 BPF "實例"實體的邏輯名稱 (例如 "incidentprocess", "new_mycasebpf")
        private const string CASE_BPF_INSTANCE_ENTITY_NAME = "LOGICAL_NAME_HERE_FOR_BPF_INSTANCE";
        // BPF 中 "結案" 階段的 Stage ID (GUID)
        private readonly Guid BPF_STAGE_ID_CLOSED = new Guid("GUID_HERE_FOR_CLOSED_STAGE");
        // BPF 實例的 "完成 (Completed)" 狀態的 statecode 值 (通常是 1)
        private const int BPF_INSTANCE_STATECODE_COMPLETED = 1;
        // BPF 實例的 "完成/結束 (Finished/Aborted 等)" 狀態原因的 statuscode 值 (例如 2)
        private const int BPF_INSTANCE_STATUSCODE_FINISHED = OPTIONSSET_VALUE_HERE_FOR_BPF_FINISHED;
        // BPF 實例上指向案例的查閱欄位邏輯名稱 (通常是 "bpf_incidentid")
        private const string BPF_CASE_LOOKUP_FIELD = "bpf_incidentid";
        // Process Stage 實體的邏輯名稱 (固定值)
        private const string PROCESS_STAGE_ENTITY_NAME = "processstage";

        // --- PluginHandler 實作 ---
        protected override string PluginName => "IncidentAutoResolutionPlugin";
        public override LogLevel CurrentLogLevel => LogLevel.Debug; // 開發時設為 Debug
        // 由於我們依賴 PostImage，嚴格來說 Target 不是必須的，但保留它可以驗證觸發欄位
        protected override string[] RequiredInputParameters => new string[] { "Target" };

        public void Execute(IServiceProvider serviceProvider)
        {
            Run(serviceProvider); // 呼叫基底類別的 Run 方法
        }

        // --- 核心邏輯 ---
        protected override void ExecuteCore()
        {
            Log(LogLevel.Debug, "進入 IncidentAutoResolutionPlugin ExecuteCore (Post-Operation)。");

            // 1. 基本驗證
            if (_context.MessageName.ToLower() != "update")
            {
                Log(LogLevel.Debug, $"非 Update 訊息 ({_context.MessageName})，插件結束。");
                return;
            }
            if (_context.PrimaryEntityName.ToLower() != "msdyn_workorder")
            {
                 Log(LogLevel.Debug, $"非 Work Order 實體 ({_context.PrimaryEntityName})，插件結束。");
                 return;
            }

            // 2. 深度檢查
            if (_context.Depth > 1)
            {
                Log(LogLevel.Warning, $"插件執行深度已達 {_context.Depth}，為避免無限迴圈，提前結束。");
                return;
            }

            // 3. 取得 Post Image (必須在註冊時設定，包含 msdyn_substatus 和 CASE_LOOKUP_ON_WO)
            Entity postImage = GetPostImage("PostImage"); // 使用基底類別的輔助方法
            if (postImage == null)
            {
                Log(LogLevel.Error, "無法取得名為 'PostImage' 的 PostEntityImage。請檢查 Plugin Step 註冊設定！插件結束。");
                return;
            }

            // 4. 檢查觸發工單的子狀態是否為目標結案狀態 (使用 GUID)
            EntityReference woSubStatusRef = postImage.GetAttributeValue<EntityReference>("msdyn_substatus");
            if (woSubStatusRef == null || !ClosedWoSubstatusGuids.Contains(woSubStatusRef.Id))
            {
                Log(LogLevel.Debug, $"工單子狀態 ({woSubStatusRef?.Id}) 不是目標結案狀態 GUID，無需處理。");
                return;
            }

            // 5. 取得父案例的 EntityReference
            EntityReference parentCaseRef = postImage.GetAttributeValue<EntityReference>(CASE_LOOKUP_ON_WO);
            if (parentCaseRef == null)
            {
                Log(LogLevel.Info, "此工單沒有關聯的父案例，無需處理。");
                return;
            }
            Guid parentCaseId = parentCaseRef.Id;
            Log(LogLevel.Info, $"觸發工單 {_context.PrimaryEntityId} 已結案 (子狀態 GUID: {woSubStatusRef.Id})，開始檢查父案例 {parentCaseId} 的所有工單狀態。");

            // 6. 查詢與該案例關聯的所有工單的子狀態
            QueryExpression query = new QueryExpression("msdyn_workorder");
            query.ColumnSet = new ColumnSet("msdyn_substatus");
            query.Criteria.AddCondition(CASE_LOOKUP_ON_WO, ConditionOperator.Equal, parentCaseId);

            EntityCollection relatedWOs;
            try
            {
                 relatedWOs = _service.RetrieveMultiple(query);
            }
            catch(Exception ex)
            {
                 Log(LogLevel.Error, $"查詢關聯工單時發生錯誤: {ex.Message}");
                 // 根據情況決定是否拋出錯誤，這裡選擇不拋出，記錄為主
                 return;
            }
            Log(LogLevel.Debug, $"找到 {relatedWOs.Entities.Count} 個與案例關聯的工單。");

            // 7. 檢查是否所有工單都已是結案狀態 (使用 GUID)
            bool allWorkOrdersClosed = true;
            foreach (Entity wo in relatedWOs.Entities)
            {
                EntityReference currentWoSubStatusRef = wo.GetAttributeValue<EntityReference>("msdyn_substatus");
                // 如果任何一個工單的子狀態為 null 或 其 GUID 不在我們的結案 GUID 清單中
                if (currentWoSubStatusRef == null || !ClosedWoSubstatusGuids.Contains(currentWoSubStatusRef.Id))
                {
                    allWorkOrdersClosed = false;
                    Log(LogLevel.Info, $"找到未結案工單 {wo.Id} (子狀態 GUID: {currentWoSubStatusRef?.Id})，案例不自動結案。");
                    break; // 找到一個就足以判斷，跳出迴圈
                }
            }

            // 8. 如果所有工單都已結案，則執行案例結案動作
            if (allWorkOrdersClosed)
            {
                Log(LogLevel.Info, $"案例 {parentCaseId} 的所有關聯工單均已結案，準備自動結案案例。");

                try
                {
                    // (a) 取得案例資料，檢查是否需要結案
                    Log(LogLevel.Debug, "檢查案例當前狀態和類型...");
                    Entity currentCase = _service.Retrieve("incident", parentCaseId,
                        new ColumnSet("statecode", CASE_TYPE_FIELD)); // 只需讀取必要欄位

                    OptionSetValue currentStateCode = currentCase.GetAttributeValue<OptionSetValue>("statecode");
                    OptionSetValue currentCaseType = currentCase.GetAttributeValue<OptionSetValue>(CASE_TYPE_FIELD);

                    if (currentStateCode != null && currentStateCode.Value == CASE_STATECODE_RESOLVED)
                    {
                        Log(LogLevel.Info, $"案例 {parentCaseId} 狀態已經是 Resolved，無需重複結案。");
                        return;
                    }
                    if (currentCaseType != null && currentCaseType.Value == CASE_TYPE_CONSULTING)
                    {
                        Log(LogLevel.Info, $"案例 {parentCaseId} 是諮詢類型 ({CASE_TYPE_CONSULTING})，不自動結案。");
                        return;
                    }
                    Log(LogLevel.Debug, "案例狀態和類型檢查通過。");

                    // (b) 更新案例狀態和狀態原因
                    Log(LogLevel.Info, $"準備更新案例 {parentCaseId} 狀態為 Resolved({CASE_STATECODE_RESOLVED})/Problem Solved({CASE_STATUSCODE_PROBLEM_SOLVED})...");
                    Entity caseToUpdate = new Entity("incident", parentCaseId);
                    caseToUpdate["statecode"] = new OptionSetValue(CASE_STATECODE_RESOLVED);
                    caseToUpdate["statuscode"] = new OptionSetValue(CASE_STATUSCODE_PROBLEM_SOLVED);
                    _service.Update(caseToUpdate);
                    Log(LogLevel.Info, $"成功更新案例 {parentCaseId} 狀態。");

                    // (c) 更新 BPF 階段到 "結案" 並完成
                    Log(LogLevel.Info, $"準備更新案例 {parentCaseId} 的 BPF ({CASE_BPF_INSTANCE_ENTITY_NAME}) 階段...");
                    QueryExpression bpfQuery = new QueryExpression(CASE_BPF_INSTANCE_ENTITY_NAME);
                    bpfQuery.ColumnSet = new ColumnSet("activityid", "activestageid", "statecode"); // activityid 是主鍵
                    bpfQuery.Criteria.AddCondition(BPF_CASE_LOOKUP_FIELD, ConditionOperator.Equal, parentCaseId);
                    bpfQuery.Criteria.AddCondition("statecode", ConditionOperator.Equal, 0); // 通常只更新 Active 狀態的 BPF 實例
                    bpfQuery.Orders.Add(new OrderExpression("createdon", OrderType.Descending));
                    bpfQuery.TopCount = 1; // 一般一個記錄只有一個 Active 的 BPF 實例

                    EntityCollection bpfInstances = _service.RetrieveMultiple(bpfQuery);

                    if (bpfInstances.Entities.Any())
                    {
                        Entity activeBpfInstance = bpfInstances.Entities[0];
                        Guid bpfInstanceId = activeBpfInstance.Id;
                        EntityReference currentStageRef = activeBpfInstance.GetAttributeValue<EntityReference>("activestageid");

                        // 檢查是否已在目標階段或 BPF 已完成
                        if (currentStageRef != null && currentStageRef.Id == BPF_STAGE_ID_CLOSED) {
                            Log(LogLevel.Info, $"BPF 實例 {bpfInstanceId} 已在結案階段，無需重複設定階段。檢查是否需完成狀態...");
                             // 即使階段對了，也可能需要將 BPF 實例狀態設為完成
                        }

                        Log(LogLevel.Debug, $"找到 Active BPF 實例: {bpfInstanceId}，準備更新...");
                        Entity bpfInstanceToUpdate = new Entity(CASE_BPF_INSTANCE_ENTITY_NAME, bpfInstanceId);
                        // 設定 Active Stage 為結案階段
                        bpfInstanceToUpdate["activestageid"] = new EntityReference(PROCESS_STAGE_ENTITY_NAME, BPF_STAGE_ID_CLOSED);
                        // 設定 BPF 狀態為完成/結束
                        bpfInstanceToUpdate["statecode"] = new OptionSetValue(BPF_INSTANCE_STATECODE_COMPLETED);
                        bpfInstanceToUpdate["statuscode"] = new OptionSetValue(BPF_INSTANCE_STATUSCODE_FINISHED);

                        _service.Update(bpfInstanceToUpdate);
                        Log(LogLevel.Info, $"成功更新 BPF 實例 {bpfInstanceId} 到結案階段並完成。");

                    }
                    else
                    {
                        Log(LogLevel.Warning, $"案例 {parentCaseId} 找不到關聯的 Active BPF 實例 ({CASE_BPF_INSTANCE_ENTITY_NAME})。無法更新 BPF 階段。");
                    }
                }
                catch (Exception ex)
                {
                    Log(LogLevel.Error, $"自動結案案例 {parentCaseId} 或更新 BPF 時發生錯誤: {ex.ToString()}");
                    // 建議不在此處拋出例外，記錄錯誤即可
                }
            }
            else
            {
                Log(LogLevel.Info, $"案例 {parentCaseId} 尚有未結案的工單，不執行自動結案。");
            }

            Log(LogLevel.Debug, "離開 IncidentAutoResolutionPlugin ExecuteCore (Post-Operation)。");
        }
    }
}
```

**再次強調：**

- **替換佔位符：** 使用前，**務必**替換掉所有 `GUID_HERE_...`, `OPTIONSSET_VALUE_HERE_...`, `LOGICAL_NAME_HERE_...`。
- **Plugin 註冊：**
    - **Message:** Update
    - **Primary Entity:** msdyn_workorder
    - **Filtering Attributes:** msdyn_substatus
    - **Stage:** Post-operation
    - **Execution Mode:** Synchronous (建議)
    - **Post Image:** 註冊名為 `PostImage` 的 Post Entity Image，包含 `msdyn_substatus` 和 `msdyn_servicerequest` (或實際的案例查閱欄位) 欄位。
- **測試：** 在開發或測試環境中充分測試各種情況（只有一個工單、多個工單、諮詢類型案例、已經解決的案例、沒有 BPF 的案例等）。

---

好的，這就提供完整的 Plugin 程式碼 (使用 Post-operation 搭配 Post Image 的建議方案) 以及詳細的流程邏輯說明。

**重要：** 請務必將程式碼中標示為 `!!! 必須替換 !!!` 的區段，以及所有 `GUID_HERE...`, `OPTIONSSET_VALUE_HERE...`, `LOGICAL_NAME_HERE...` 的佔位符，替換成你 Dynamics 365 環境中的 **實際值**。

**完整的 Plugin 程式碼 (C#):**

C#

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Query;
using Twtoto.ASManagement.Core; // 引用你的 PluginHandler 基礎類別

namespace Twtoto.ASManagement.IncidentPlugins.Plugins
{
    /// <summary>
    /// 當案例關聯的所有工單都結案時，自動解決該案例並完成 BPF。
    /// 觸發點：Work Order 更新 (Post-Operation)
    /// </summary>
    public class IncidentAutoResolutionPlugin : PluginHandler, IPlugin
    {
        #region --- 配置值 (!!! 必須根據你的環境替換 !!!) ---

        // --- 工單子狀態 (msdyn_workordersubstatus) ---
        // "自動結案" 記錄的 GUID
        private readonly Guid WO_SUBSTATUS_AUTO_CLOSED_GUID = new Guid("GUID_HERE_FOR_AUTO_CLOSED"); // <--- 替換!
        // "審核結案" 記錄的 GUID
        private readonly Guid WO_SUBSTATUS_REVIEW_CLOSED_GUID = new Guid("GUID_HERE_FOR_REVIEW_CLOSED"); // <--- 替換!
        // 將結案狀態的 GUID 放入 List，方便檢查
        private List<Guid> ClosedWoSubstatusGuids => new List<Guid> { WO_SUBSTATUS_AUTO_CLOSED_GUID, WO_SUBSTATUS_REVIEW_CLOSED_GUID };

        // --- 案例 (incident) ---
        // "已解決 (Resolved)" 狀態的 statecode 值 (通常是 1)
        private const int CASE_STATECODE_RESOLVED = 1;
        // "問題已解決 (Problem Solved)" 狀態原因的 statuscode 值 (例如 5)
        private const int CASE_STATUSCODE_PROBLEM_SOLVED = OPTIONSSET_VALUE_HERE_FOR_PROBLEM_SOLVED; // <--- 替換!
        // 案例類型欄位的邏輯名稱 (例如 "casetypecode")
        private const string CASE_TYPE_FIELD = "LOGICAL_NAME_HERE_FOR_CASETYPE"; // <--- 替換!
        // "諮詢" 類型的選項值
        private const int CASE_TYPE_CONSULTING = OPTIONSSET_VALUE_HERE_FOR_CONSULTING; // <--- 替換!
        // 工單上指向案例的查閱欄位邏輯名稱 (通常是 "msdyn_servicerequest")
        private const string CASE_LOOKUP_ON_WO = "msdyn_servicerequest"; // <--- 如果不同請替換!

        // --- 案例業務流程 (BPF) ---
        // 案例所使用的 BPF "實例"實體的邏輯名稱 (例如 "incidentprocess", "new_mycasebpf")
        private const string CASE_BPF_INSTANCE_ENTITY_NAME = "LOGICAL_NAME_HERE_FOR_BPF_INSTANCE"; // <--- 替換!
        // BPF 中 "結案" 階段的 Stage ID (GUID)
        private readonly Guid BPF_STAGE_ID_CLOSED = new Guid("GUID_HERE_FOR_CLOSED_STAGE"); // <--- 替換!
        // BPF 實例的 "完成 (Completed)" 狀態的 statecode 值 (通常是 1)
        private const int BPF_INSTANCE_STATECODE_COMPLETED = 1;
        // BPF 實例的 "完成/結束 (Finished/Aborted 等)" 狀態原因的 statuscode 值 (例如 2)
        private const int BPF_INSTANCE_STATUSCODE_FINISHED = OPTIONSSET_VALUE_HERE_FOR_BPF_FINISHED; // <--- 替換!
        // BPF 實例上指向案例的查閱欄位邏輯名稱 (通常是 "bpf_incidentid")
        private const string BPF_CASE_LOOKUP_FIELD = "bpf_incidentid"; // <--- 如果不同請替換!
        // Process Stage 實體的邏輯名稱 (固定值)
        private const string PROCESS_STAGE_ENTITY_NAME = "processstage";
        // Post Image 的別名 (需要與註冊時一致)
        private const string POST_IMAGE_ALIAS = "PostImage";

        #endregion

        #region --- PluginHandler 實作 ---
        protected override string PluginName => "IncidentAutoResolutionPlugin";
        public override LogLevel CurrentLogLevel => LogLevel.Debug; // 開發/測試階段使用 Debug
        // 雖然依賴 PostImage，但 Target 參數預設存在於 Update 訊息中
        protected override string[] RequiredInputParameters => new string[] { "Target" };

        /// <summary>
        /// Plugin 的主執行入口點
        /// </summary>
        public void Execute(IServiceProvider serviceProvider)
        {
            // 呼叫基底類別的 Run 方法來處理初始化、記錄、錯誤處理和呼叫 ExecuteCore
            base.Run(serviceProvider);
        }
        #endregion

        #region --- 核心邏輯 ---
        /// <summary>
        /// 包含主要業務邏輯的方法，由基底類別的 Run 方法呼叫。
        /// </summary>
        protected override void ExecuteCore()
        {
            Log(LogLevel.Debug, "===== 開始執行 IncidentAutoResolutionPlugin (Post-Operation) =====");

            // 1. 基本驗證 (由基底類別的 Run 和此處檢查確保)
            if (!ValidateContext()) return;

            // 2. 深度檢查 (防止無限循環)
            if (_context.Depth > 1)
            {
                Log(LogLevel.Warning, $"插件執行深度已達 {_context.Depth}，為避免無限迴圈，提前結束。");
                return;
            }

            // 3. 取得 Post Image (在 Plugin Step 註冊時必須設定好)
            Entity postImage = GetPostImage(POST_IMAGE_ALIAS);
            if (postImage == null)
            {
                LogError($"無法取得名為 '{POST_IMAGE_ALIAS}' 的 PostEntityImage。請檢查 Plugin Step 註冊設定！插件結束。");
                return;
            }
            LogDebug($"成功取得 Post Image: {POST_IMAGE_ALIAS}");

            // 4. 檢查觸發工單的子狀態是否為目標結案狀態 (使用 GUID)
            EntityReference woSubStatusRef = postImage.GetAttributeValue<EntityReference>("msdyn_substatus");
            if (woSubStatusRef == null || !ClosedWoSubstatusGuids.Contains(woSubStatusRef.Id))
            {
                LogInfo($"觸發工單 {_context.PrimaryEntityId} 的子狀態 ({woSubStatusRef?.Id}) 不是目標結案狀態，無需處理。");
                return;
            }
            LogInfo($"觸發工單 {_context.PrimaryEntityId} 的子狀態符合結案條件 (GUID: {woSubStatusRef.Id})。");

            // 5. 取得父案例的 EntityReference
            EntityReference parentCaseRef = postImage.GetAttributeValue<EntityReference>(CASE_LOOKUP_ON_WO);
            if (parentCaseRef == null)
            {
                LogInfo($"工單 {_context.PrimaryEntityId} 沒有關聯的父案例 ({CASE_LOOKUP_ON_WO})，無需處理。");
                return;
            }
            Guid parentCaseId = parentCaseRef.Id;
            LogInfo($"開始檢查父案例 {parentCaseId} 的所有工單狀態。");

            // 6. 檢查是否所有相關工單都已結案
            bool allWorkOrdersClosed = CheckIfAllWorkOrdersAreClosed(parentCaseId);

            // 7. 如果所有工單都已結案，則執行案例結案動作
            if (allWorkOrdersClosed)
            {
                LogInfo($"案例 {parentCaseId} 的所有關聯工單均已結案，準備自動結案案例。");
                ResolveCaseAndFinishBPF(parentCaseId);
            }
            else
            {
                LogInfo($"案例 {parentCaseId} 尚有未結案的工單，不執行自動結案。");
            }

            Log(LogLevel.Debug, "===== 結束執行 IncidentAutoResolutionPlugin =====");
        }
        #endregion

        #region --- 私有輔助方法 ---

        /// <summary>
        /// 執行基本的上下文驗證
        /// </summary>
        /// <returns>如果上下文有效則返回 true，否則返回 false</returns>
        private bool ValidateContext()
        {
            if (_context.MessageName.ToLower() != "update")
            {
                LogDebug($"非 Update 訊息 ({_context.MessageName})，插件結束。");
                return false;
            }
            if (_context.PrimaryEntityName.ToLower() != "msdyn_workorder")
            {
                LogDebug($"非 Work Order 實體 ({_context.PrimaryEntityName})，插件結束。");
                return false;
            }
            // 可以在這裡加入更多驗證，例如檢查 Stage 是否為 PostOperation
            if (_context.Stage != 40) // 40 = PostOperation
            {
                 LogDebug($"非 PostOperation 階段 ({_context.Stage})，插件結束。");
                 return false;
            }
            return true;
        }

        /// <summary>
        /// 查詢並檢查指定案例下的所有工單是否都處於結案狀態子類別。
        /// </summary>
        /// <param name="caseId">要檢查的案例 ID</param>
        /// <returns>如果所有工單都已結案則返回 true，否則返回 false</returns>
        private bool CheckIfAllWorkOrdersAreClosed(Guid caseId)
        {
            LogDebug($"開始查詢案例 {caseId} 的所有關聯工單狀態...");
            QueryExpression query = new QueryExpression("msdyn_workorder");
            query.ColumnSet = new ColumnSet("msdyn_substatus"); // 只需要檢查狀態子類別
            query.Criteria.AddCondition(CASE_LOOKUP_ON_WO, ConditionOperator.Equal, caseId);
            // (可選) 可以排除已取消的工單不算在內
            // query.Criteria.AddCondition("statecode", ConditionOperator.NotEqual, 2); // 假設 2 代表 Inactive

            EntityCollection relatedWOs;
            try
            {
                relatedWOs = _service.RetrieveMultiple(query);
            }
            catch (Exception ex)
            {
                LogError($"查詢案例 {caseId} 的關聯工單時發生錯誤: {ex.ToString()}");
                return false; // 查詢出錯，無法判斷，返回 false
            }

            LogDebug($"找到 {relatedWOs.Entities.Count} 個關聯工單。開始逐一檢查狀態...");

            if (!relatedWOs.Entities.Any()) {
                 LogInfo($"案例 {caseId} 沒有找到任何關聯的工單。");
                 // 根據業務邏輯決定：如果沒有工單是否算 "全部完成"？這裡假設是。
                 return true;
            }

            foreach (Entity wo in relatedWOs.Entities)
            {
                EntityReference currentWoSubStatusRef = wo.GetAttributeValue<EntityReference>("msdyn_substatus");
                // 如果任何一個工單的子狀態為 null 或 其 GUID 不在我們的結案 GUID 清單中
                if (currentWoSubStatusRef == null || !ClosedWoSubstatusGuids.Contains(currentWoSubStatusRef.Id))
                {
                    LogInfo($"找到未結案工單 {wo.Id} (子狀態 GUID: {currentWoSubStatusRef?.Id})。");
                    return false; // 找到一個未結案，即可確定結果
                }
            }

            LogDebug($"所有 {relatedWOs.Entities.Count} 個工單都處於結案狀態。");
            return true; // 所有工單都通過檢查
        }

        /// <summary>
        /// 解決指定的案例，並嘗試將其 BPF 移至結案階段並完成。
        /// </summary>
        /// <param name="caseId">要解決的案例 ID</param>
        private void ResolveCaseAndFinishBPF(Guid caseId)
        {
            try
            {
                // (a) 檢查案例是否需要結案
                LogDebug($"檢查案例 {caseId} 當前狀態和類型...");
                Entity currentCase = _service.Retrieve("incident", caseId,
                    new ColumnSet("statecode", CASE_TYPE_FIELD));

                OptionSetValue currentStateCode = currentCase.GetAttributeValue<OptionSetValue>("statecode");
                OptionSetValue currentCaseType = currentCase.GetAttributeValue<OptionSetValue>(CASE_TYPE_FIELD);

                if (currentStateCode != null && currentStateCode.Value == CASE_STATECODE_RESOLVED)
                {
                    LogInfo($"案例 {caseId} 狀態已經是 Resolved，無需重複結案。");
                    return;
                }
                if (currentCaseType != null && currentCaseType.Value == CASE_TYPE_CONSULTING)
                {
                    LogInfo($"案例 {caseId} 是諮詢類型 ({CASE_TYPE_CONSULTING})，不自動結案。");
                    return;
                }
                LogDebug("案例狀態和類型檢查通過。");

                // (b) 更新案例狀態和狀態原因
                LogInfo($"準備更新案例 {caseId} 狀態為 Resolved({CASE_STATECODE_RESOLVED})/Problem Solved({CASE_STATUSCODE_PROBLEM_SOLVED})...");
                Entity caseToUpdate = new Entity("incident", caseId);
                caseToUpdate["statecode"] = new OptionSetValue(CASE_STATECODE_RESOLVED);
                caseToUpdate["statuscode"] = new OptionSetValue(CASE_STATUSCODE_PROBLEM_SOLVED);
                _service.Update(caseToUpdate);
                LogInfo($"成功更新案例 {caseId} 狀態。");

                // (c) 更新 BPF 階段到 "結案" 並完成
                UpdateBPFToClosedStage(caseId);

            }
            catch (Exception ex)
            {
                LogError($"自動結案案例 {caseId} 時發生主要錯誤: {ex.ToString()}");
                // 根據需要決定是否向上拋出錯誤
            }
        }


        /// <summary>
        /// 嘗試查詢並更新指定案例關聯的 BPF 實例到結案階段。
        /// </summary>
        /// <param name="caseId">案例 ID</param>
        private void UpdateBPFToClosedStage(Guid caseId)
        {
             LogInfo($"準備更新案例 {caseId} 的 BPF ({CASE_BPF_INSTANCE_ENTITY_NAME}) 階段...");

             try
             {
                 // 查詢與案例關聯的 Active BPF 實例記錄
                 QueryExpression bpfQuery = new QueryExpression(CASE_BPF_INSTANCE_ENTITY_NAME);
                 bpfQuery.ColumnSet = new ColumnSet("activityid", "activestageid", "statecode"); // activityid 是 BPF 實例的主鍵
                 bpfQuery.Criteria.AddCondition(BPF_CASE_LOOKUP_FIELD, ConditionOperator.Equal, caseId);
                 bpfQuery.Criteria.AddCondition("statecode", ConditionOperator.Equal, 0); // 0 = Active
                 bpfQuery.Orders.Add(new OrderExpression("createdon", OrderType.Descending)); // 如果有多個 Active (不應發生)，取最新的
                 bpfQuery.TopCount = 1;

                 EntityCollection bpfInstances = _service.RetrieveMultiple(bpfQuery);

                 if (bpfInstances.Entities.Any())
                 {
                     Entity activeBpfInstance = bpfInstances.Entities[0];
                     Guid bpfInstanceId = activeBpfInstance.Id;
                     EntityReference currentStageRef = activeBpfInstance.GetAttributeValue<EntityReference>("activestageid");
                     OptionSetValue currentBpfStateCode = activeBpfInstance.GetAttributeValue<OptionSetValue>("statecode");

                     LogDebug($"找到 Active BPF 實例: {bpfInstanceId}，當前階段: {currentStageRef?.Id}，當前狀態: {currentBpfStateCode?.Value}");

                     // 檢查是否已在目標階段或 BPF 已完成
                     if (currentStageRef != null && currentStageRef.Id == BPF_STAGE_ID_CLOSED &&
                         currentBpfStateCode != null && currentBpfStateCode.Value == BPF_INSTANCE_STATECODE_COMPLETED)
                     {
                           LogInfo($"BPF 實例 {bpfInstanceId} 已在結案階段且狀態已完成，無需更新。");
                           return;
                     }

                     // 建立更新物件
                     Entity bpfInstanceToUpdate = new Entity(CASE_BPF_INSTANCE_ENTITY_NAME, bpfInstanceId);
                     // 設定 Active Stage 為結案階段
                     bpfInstanceToUpdate["activestageid"] = new EntityReference(PROCESS_STAGE_ENTITY_NAME, BPF_STAGE_ID_CLOSED);
                     // 設定 BPF 狀態為完成/結束
                     bpfInstanceToUpdate["statecode"] = new OptionSetValue(BPF_INSTANCE_STATECODE_COMPLETED);
                     bpfInstanceToUpdate["statuscode"] = new OptionSetValue(BPF_INSTANCE_STATUSCODE_FINISHED);

                     LogDebug($"準備更新 BPF 實例 {bpfInstanceId}，設定 Active Stage ID 為 {BPF_STAGE_ID_CLOSED}，狀態為 Completed({BPF_INSTANCE_STATECODE_COMPLETED})/Finished({BPF_INSTANCE_STATUSCODE_FINISHED})...");
                     _service.Update(bpfInstanceToUpdate);
                     LogInfo($"成功更新 BPF 實例 {bpfInstanceId} 到結案階段並完成。");
                 }
                 else
                 {
                     LogWarning($"案例 {caseId} 找不到關聯的 Active BPF 實例 ({CASE_BPF_INSTANCE_ENTITY_NAME})。無法更新 BPF 階段。");
                 }
             }
             catch(Exception ex)
             {
                 LogError($"更新案例 {caseId} 的 BPF 時發生錯誤: {ex.ToString()}");
                 // 記錄錯誤，但不影響案例本身的結案狀態
             }
        }

        #endregion
    }
}
```

**流程邏輯說明：**

1. **觸發 (Plugin Registration - 需要手動設定)**
    
    - 當系統中有任何 `msdyn_workorder` (工單) 記錄被 **更新 (Update)**。
    - 且更新的欄位**包含** `msdyn_substatus` (狀態子類別 - 透過 Filtering Attributes 設定)。
    - 且主要的資料庫儲存動作**完成之後** (`Post-operation` 階段)。
    - Plugin `IncidentAutoResolutionPlugin` 的 `Execute` 方法被觸發。
2. **初始化與基本驗證 (`Run` -> `ExecuteCore` -> `ValidateContext`)**
    
    - `Execute` 呼叫 `Run`。
    - `Run` 方法初始化 `_context`, `_service`, `_tracer`。
    - `Run` 記錄開始訊息。
    - `Run` 呼叫 `ExecuteCore`。
    - `ExecuteCore` 首先呼叫 `ValidateContext` 檢查：
        - 是否為 `Update` 訊息？
        - 主要實體是否為 `msdyn_workorder`？
        - 執行階段是否為 `Post-operation` (Stage 40)？
        - 如果任一條件不符，記錄原因並直接結束 (`return`)。
3. **深度檢查 (`ExecuteCore`)**
    
    - 檢查 `_context.Depth` 是否大於 1。如果是，表示可能是由其他 Plugin 或 Workflow 在同一個交易中連鎖觸發的，為避免無限循環，記錄警告並結束。
4. **取得 Post Image (`ExecuteCore` -> `GetPostImage`)**
    
    - 嘗試從 `_context.PostEntityImages` 中獲取名為 `"PostImage"` 的快照。
    - 這個 Image 必須在註冊 Plugin Step 時設定好，並包含 `msdyn_substatus` 和 `msdyn_servicerequest` 欄位。
    - 如果獲取失敗，記錄錯誤並結束（因為後續邏輯需要這兩個欄位）。
5. **檢查觸發工單的子狀態 (`ExecuteCore`)**
    
    - 從 Post Image 中讀取 `msdyn_substatus` 欄位的值 (這是一個 `EntityReference`)。
    - 檢查這個 `EntityReference` 是否為 `null`，或者它的 `Id` (GUID) 是否**不**在預先定義的結案狀態 GUID 列表 (`ClosedWoSubstatusGuids`) 中。
    - 如果不符合結案條件，記錄原因並結束。
6. **取得父案例 ID (`ExecuteCore`)**
    
    - 從 Post Image 中讀取 `msdyn_servicerequest` 欄位的值 (父案例的 `EntityReference`)。
    - 如果為 `null` (表示工單沒有關聯案例)，記錄原因並結束。
    - 儲存父案例的 GUID (`parentCaseId`)。
7. **檢查所有相關工單狀態 (`ExecuteCore` -> `CheckIfAllWorkOrdersAreClosed`)**
    
    - 呼叫輔助方法 `CheckIfAllWorkOrdersAreClosed`，傳入父案例 ID。
    - `CheckIfAllWorkOrdersAreClosed` 方法執行：
        - 使用 `RetrieveMultiple` 查詢所有 `msdyn_servicerequest` 等於傳入 `caseId` 的工單，只查詢 `msdyn_substatus` 欄位。
        - 如果查詢出錯，記錄錯誤並返回 `false`。
        - 如果找不到任何工單，根據業務邏輯可能視為「全部完成」，返回 `true`。
        - 遍歷查詢到的所有工單。
        - 對於每一筆工單，檢查其 `msdyn_substatus` 的 `EntityReference.Id` 是否為 `null` 或不在 `ClosedWoSubstatusGuids` 列表中。
        - **只要找到任何一筆不符合**，就立刻返回 `false`。
        - 如果所有工單都檢查完畢且都符合結案狀態，返回 `true`。
8. **條件判斷 (`ExecuteCore`)**
    
    - 檢查 `CheckIfAllWorkOrdersAreClosed` 的返回值。如果為 `false`（表示尚有未結案工單），記錄原因並結束。
9. **執行案例結案與 BPF 更新 (`ExecuteCore` -> `ResolveCaseAndFinishBPF`)**
    
    - 如果 `CheckIfAllWorkOrdersAreClosed` 返回 `true`，則呼叫輔助方法 `ResolveCaseAndFinishBPF`，傳入父案例 ID。
    - `ResolveCaseAndFinishBPF` 方法執行：
        - **(a) 讀取案例資料：** `Retrieve` 該案例，獲取當前的 `statecode` 和案例類型欄位 (`CASE_TYPE_FIELD`)。
        - **(b) 條件檢查：** 檢查案例是否已經是 `Resolved` 狀態，或者案例類型是否為「諮詢」。如果是，記錄原因並結束此方法。
        - **(c) 更新案例狀態：** 建立一個 `Entity` 物件，設定 `statecode` 為 `Resolved`，`statuscode` 為 `Problem Solved`，然後呼叫 `_service.Update()` 更新案例。
        - **(d) 更新 BPF (呼叫 `UpdateBPFToClosedStage`)：** 呼叫另一個輔助方法來處理 BPF 更新。
    - `UpdateBPFToClosedStage` 方法執行：
        - 查詢與案例關聯的、狀態為 Active 的 BPF 實例記錄 (使用 `CASE_BPF_INSTANCE_ENTITY_NAME` 和 `BPF_CASE_LOOKUP_FIELD`)。
        - 如果找不到 Active 的 BPF 實例，記錄警告並結束。
        - 如果找到了，檢查當前 BPF 階段是否已是目標結案階段 (`BPF_STAGE_ID_CLOSED`) 且 BPF 實例狀態是否已完成。如果是，則無需重複更新，結束。
        - 建立一個 `Entity` 物件代表要更新的 BPF 實例。
        - 設定 `activestageid` 為目標結案階段的 `EntityReference`。
        - 設定 BPF 實例的 `statecode` 和 `statuscode` 為完成狀態的值。
        - 呼叫 `_service.Update()` 更新 BPF 實例。
        - 包含 `try-catch` 以記錄 BPF 更新過程中可能發生的錯誤，但不讓它中斷整個 Plugin 流程。
10. **記錄結束 (`Run` 的 `finally` 區塊)**
    
    - 無論成功或失敗，`Run` 方法的 `finally` 區塊都會記錄 Plugin 執行的結束訊息。

這個流程確保了只有在**所有**條件（包括觸發條件、所有工單狀態、案例狀態和類型）都滿足時，才會執行案例和 BPF 的更新操作，並且包含了必要的檢查和基本的錯誤處理。

---

```csharp
public class CombinedIncidentAutoResolutionPlugin : PluginHandler, IPlugin
{
    // 配置值 (集中管理)
    private readonly Guid WO_SUBSTATUS_AUTO_CLOSED_GUID = new Guid("YOUR_GUID");
    private readonly Guid WO_SUBSTATUS_REVIEW_CLOSED_GUID = new Guid("YOUR_GUID");
    private readonly List<Guid> ClosedWoSubstatusGuids => new List<Guid> { WO_SUBSTATUS_AUTO_CLOSED_GUID, WO_SUBSTATUS_REVIEW_CLOSED_GUID };
    private const string CASE_LOOKUP_ON_WO = "msdyn_servicerequest"; // 確認正確欄位
    private const string CASE_BPF_INSTANCE_ENTITY_NAME = "YOUR_BPF_ENTITY_NAME";
    private readonly Guid BPF_STAGE_ID_CLOSED = new Guid("YOUR_GUID");
    private const int CASE_TYPE_CONSULTING = YOUR_VALUE;

    protected override string PluginName => "CombinedIncidentAutoResolutionPlugin";
    public override LogLevel CurrentLogLevel => LogLevel.Debug;
    protected override string[] RequiredInputParameters => new string[] { "Target" };

    public void Execute(IServiceProvider serviceProvider) => Run(serviceProvider);

    protected override void ExecuteCore()
    {
        Log(LogLevel.Debug, "Starting CombinedIncidentAutoResolutionPlugin");

        // 1. 驗證消息和實體
        if (_context.MessageName.ToLower() != "update" || _context.PrimaryEntityName.ToLower() != "msdyn_workorder")
        {
            Log(LogLevel.Debug, "Not an update on msdyn_workorder, exiting.");
            return;
        }

        // 2. 檢查遞迴深度
        if (_context.Depth > 1)
        {
            Log(LogLevel.Warning, "Depth > 1, exiting to prevent recursion.");
            return;
        }

        // 3. 獲取 PostImage
        Entity postImage = GetPostImage("PostImage");
        if (postImage == null)
        {
            Log(LogLevel.Error, "PostImage not found, exiting.");
            return;
        }

        // 4. 檢查子狀態
        EntityReference woSubStatusRef = postImage.GetAttributeValue<EntityReference>("msdyn_substatus");
        if (woSubStatusRef == null || !ClosedWoSubstatusGuids.Contains(woSubStatusRef.Id))
        {
            Log(LogLevel.Debug, "Substatus not in closed list, exiting.");
            return;
        }

        // 5. 獲取父案例
        EntityReference parentCaseRef = postImage.GetAttributeValue<EntityReference>(CASE_LOOKUP_ON_WO);
        if (parentCaseRef == null)
        {
            Log(LogLevel.Info, "No parent case, exiting.");
            return;
        }

        // 6. 檢查所有工單是否結案
        QueryExpression query = new QueryExpression("msdyn_workorder")
        {
            ColumnSet = new ColumnSet("msdyn_substatus"),
            Criteria = { Conditions = { new ConditionExpression(CASE_LOOKUP_ON_WO, ConditionOperator.Equal, parentCaseRef.Id) } }
        };
        EntityCollection relatedWOs = _service.RetrieveMultiple(query);

        bool allWorkOrdersClosed = relatedWOs.Entities.All(wo =>
        {
            var subStatusRef = wo.GetAttributeValue<EntityReference>("msdyn_substatus");
            return subStatusRef != null && ClosedWoSubstatusGuids.Contains(subStatusRef.Id);
        });

        if (!allWorkOrdersClosed)
        {
            Log(LogLevel.Info, "Not all work orders closed, exiting.");
            return;
        }

        // 7. 檢查案例狀態和類型
        Entity currentCase = _service.Retrieve("incident", parentCaseRef.Id, new ColumnSet("statecode", "casetypecode"));
        if (currentCase.GetAttributeValue<OptionSetValue>("statecode")?.Value == 1)
        {
            Log(LogLevel.Info, "Case already resolved, exiting.");
            return;
        }
        if (currentCase.GetAttributeValue<OptionSetValue>("casetypecode")?.Value == CASE_TYPE_CONSULTING)
        {
            Log(LogLevel.Info, "Case is consulting type, exiting.");
            return;
        }

        // 8. 關閉案例
        var closeRequest = new CloseIncidentRequest
        {
            IncidentResolution = new Entity("incidentresolution")
            {
                ["subject"] = "Auto-closed due to all work orders completed",
                ["incidentid"] = parentCaseRef
            },
            Status = new OptionSetValue(5) // Problem Solved
        };
        _service.Execute(closeRequest);
        Log(LogLevel.Info, "Case closed successfully.");

        // 9. 更新 BPF
        QueryExpression bpfQuery = new QueryExpression(CASE_BPF_INSTANCE_ENTITY_NAME)
        {
            ColumnSet = new ColumnSet("activityid"),
            Criteria = { Conditions = { new ConditionExpression("bpf_incidentid", ConditionOperator.Equal, parentCaseRef.Id) } },
            TopCount = 1
        };
        EntityCollection bpfInstances = _service.RetrieveMultiple(bpfQuery);

        if (bpfInstances.Entities.Any())
        {
            Entity bpfInstanceToUpdate = new Entity(CASE_BPF_INSTANCE_ENTITY_NAME, bpfInstances.Entities[0].Id)
            {
                ["activestageid"] = new EntityReference("processstage", BF_STAGE_ID_CLOSED),
                ["statecode"] = new OptionSetValue(1),
                ["statuscode"] = new OptionSetValue(2)
            };
            _service.Update(bpfInstanceToUpdate);
            Log(LogLevel.Info, "BPF updated to closed stage and completed.");
        }
        else
        {
            Log(LogLevel.Warning, "No active BPF instance found.");
        }
    }
}
```