#### 📅 **Date**: 2025-04-18
#### 🔖 **Tags**: #Plugin #Action #JavaScript #RibbonButton #Dynamics365 #PowerPlatform #WebApi #PluginAssembly #Dataverse

---
## 項目需求說明

此開發項目旨在透過表單上的 Ribbon Button (功能區按鈕) 來管理「開發項目」(Development Task) 的生命週期狀態，包含以下操作：

-   **交派 (Assign):** 將項目交派給指定員工。
-   **開發完成 (DevDone):** 員工完成後點擊，發起驗收通知。
-   **通過 (Approve):** 驗收成功，項目結案。
-   **退回 (Reject):** 驗收失敗，退回給員工。

---

## 元件設計概觀

為實現此功能，設計了以下元件：

### 1. 資料表與 Ribbon 按鈕設定 (Table: DevelopmentTask)

在 `DevelopmentTask` 表單上設定以下按鈕：

| 按鈕內部名稱 (ID) | 顯示名稱   | JavaScript Action Function | JavaScript Enable Function |
| :---------------- | :--------- | :------------------------- | :------------------------- |
| `BTN_Assign`      | 交派       | `Assign_action`            | `Assign_enable`            |
| `BTN_DevDone`     | 開發完成   | `DevDone_action`           | `DevDone_enable`           |
| `BTN_Approve`     | 通過       | `Approve_action`           | `Approve_enable`           |
| `BTN_Reject`      | 退回       | `Reject_action`            | `Reject_enable`            |

### 2. 前端 JavaScript 邏輯 (WebResource: DevelopmentTaskLibrary)

建立 `DevelopmentTaskLibrary.js`，包含處理上述按鈕的 `_enable` (啟用邏輯) 和 `_action` (點擊事件) 函數。`_action` 函數負責呼叫後端 Custom Action。

### 3. 後端自訂流程 (Custom Actions)

-   **`theo_SetDevelopmentTaskStatus`**
    * **Input:** `Operation` (string): "Assign", "DevDone", "Approve", "Reject"。
    * **Input:** `Target` (EntityReference: DevelopmentTask): 指向目標開發項目。
-   **`theo_SetRejectSetting`**
    * **Input:** `Target` (EntityReference: DevelopmentTask): 指向被退回的開發項目。

### 4. 後端主要邏輯 (PluginAssembly: DevelopmentTaskLogic)

建立 `DevelopmentTaskLogic.dll`，包含處理 Action 的 Plugin：

-   **`SetDevelopmentTaskStatusPlugin`**
    * **Step:** 註冊在 `theo_SetDevelopmentTaskStatus` Action (PostOperation, Sync)。
    * **邏輯:** 依 `Operation` 更新狀態/時間；若為 "Reject"，則呼叫 `theo_SetRejectSetting` Action。
-   **`SetRejectSettingPlugin`**
    * **Step:** 註冊在 `theo_SetRejectSetting` Action (PostOperation, Sync)。
    * **邏輯:** 清空交付時間、增加退回次數、增加負責人退件數。

---
## 詳細實作邏輯說明

### 1. JavaScript (DevelopmentTaskLibrary) 詳解

此 Web Resource 控制按鈕的顯示與行為。

```javascript
/** Choices Value
 * 需求確認 value: 638540000
 * 開發中 value: 638540001
 * 待審核 value: 638540002
 * 結案 value: 638540003
 */
// #region Assign
async function Assign_action(formContext) {
    // 執行Action: SetDevelopmentTaskStatus
    // 傳入參數: Operation = "Assign"
    // 成功執行Action後重新整理頁面
    console.log("Assign_action called");
    const taskOwnerAttr = formContext.getAttribute("theo_taskowner");
    const taskOwnerValue = taskOwnerAttr.getValue();
    console.log(`交派給: ${taskOwnerValue}`);
    if (!taskOwnerValue) {
        console.error("請先選擇負責人");
        return;
    }
    await callSetStatusAction(formContext, "Assign");
    console.log("Assign_action ended");
}
function Assign_enable(formContext) {
    // TaskStatus為"需求確認"時才顯示, 其他狀態皆不顯示
    console.log("Assign enable called");

    /**
     * formContext.ui.getFormType() 這個方法可以取得目前表單的模式：
     * 1: Create (建立/新增)
     * 2: Update (更新/編輯已儲存的紀錄)
     * 3: Read Only (唯讀)
     * 4: Disabled (停用)
     * 6: Bulk Edit (大量編輯)
     */
    const formType = formContext.ui.getFormType(); // 取得表單類型，確保交派按鈕只在開發項目已建立時可見
    console.log(`FormType: ${formType}`);
    const requirementValue = 638540000; // 需求確認
    const taskStatusAttr = formContext.getAttribute("theo_taskstatus");
    const taskStatusValue = taskStatusAttr.getValue();
    const isEnable = formType === 2 && taskStatusValue === requirementValue;
    console.log(`Assign_enable: ${isEnable} (taskStatusValue: ${taskStatusValue}, requirementValue: ${requirementValue})`);

    return isEnable;
}
// #endregion
// #region DevDone
async function DevDone_action(formContext) {
    // 執行Action: SetDevelopmentTaskStatus
    // 傳入參數: Operation = "DevDone"
    // 成功執行Action後重新整理頁面
    console.log("DevDone_action called");
    await callSetStatusAction(formContext, "DevDone");
    console.log("DevDone_action ended");
}
function DevDone_enable(formContext) {
    // TaskStatus為"開發中"時才顯示, 其他狀態皆不顯示
    console.log("DevDone enable called");

    const developmentValue = 638540001; // 開發中
    const formType = formContext.ui.getFormType();
    console.log(`FormType: ${formType}`);
    const taskStatusAttr = formContext.getAttribute("theo_taskstatus");
    const taskStatusValue = taskStatusAttr.getValue();
    const isEnable = formType === 2 && taskStatusValue === developmentValue;
    console.log(`DevDone_enable: ${isEnable} (taskStatusValue: ${taskStatusValue}, developmentValue: ${developmentValue})`);

    return isEnable;
}
// #endregion
// #region Approve
async function Approve_action(formContext) {
    // 執行Action: SetDevelopmentTaskStatus
    // 傳入參數: Operation = "Approve"
    // 成功執行Action後重新整理頁面
    console.log("Approve_action called");
    await callSetStatusAction(formContext, "Approve");
    console.log("Approve_action ended");
}
function Approve_enable(formContext) {
    // TaskStatus為"待審核"時才顯示, 其他狀態皆不顯示
    console.log("Approve enable called");

    const pendingValue = 638540002; // 待審核
    const formType = formContext.ui.getFormType();
    console.log(`FormType: ${formType}`);
    const taskStatusAttr = formContext.getAttribute("theo_taskstatus");
    const taskStatusValue = taskStatusAttr.getValue();
    const isEnable = formType === 2 && taskStatusValue === pendingValue;
    console.log(`Approve_enable: ${isEnable} (taskStatusValue: ${taskStatusValue}, pendingValue: ${pendingValue})`);

    return isEnable;
}
// #endregion
// #region Reject
async function Reject_action(formContext) {
    // 執行Action: SetDevelopmentTaskStatus
    // 傳入參數: Operation = "Reject"
    // 成功執行Action後重新整理頁面
    console.log("Reject_action called");
    await callSetStatusAction(formContext, "Reject");
    console.log("Reject_action ended");
}
function Reject_enable(formContext) {
    // TaskStatus為"待審核"時才顯示, 其他狀態皆不顯示
    console.log("Reject enable called");

    const pendingValue = 638540002; // 待審核
    const formType = formContext.ui.getFormType();
    console.log(`FormType: ${formType}`);
    const taskStatusAttr = formContext.getAttribute("theo_taskstatus");
    const taskStatusValue = taskStatusAttr.getValue();
    const isEnable = formType === 2 && taskStatusValue === pendingValue;
    console.log(`Reject_enable: ${isEnable} (taskStatusValue: ${taskStatusValue}, pendingValue: ${pendingValue})`);

    return isEnable;
}
// #endregion
// #region Call Action SetDevelopmentTaskStatus
async function callSetStatusAction(formContext, operation) {
    console.log("執行 callSetStatusAction");

    const recordId = formContext.data.entity.getId().replace(/[{}]/g, "");
    console.log("recordId:", recordId);
    const entityName = formContext.data.entity.getEntityName();

    const actionName = "theo_SetDevelopmentTaskStatus";

    const request = {
        Operation: operation,
        Target: {
            "@odata.type": `Microsoft.Dynamics.CRM.${entityName}`,
            [`${entityName}id`]: recordId,
        },
        getMetadata: () => ({
            parameterTypes: {
                Target: {
                    typeName: `mscrm.${entityName}`,
                    structuralProperty: 5, // EntityReference
                },
                Operation: {
                    typeName: "Edm.String",
                    structuralProperty: 1, // 基礎型別
                },
            },
            operationType: 0, // Action
            operationName: actionName,
        }),
    };

    console.log("request:", request);

    const response = await Xrm.WebApi.online.execute(request);
    if (response.ok) {
        console.log(`Action '${actionName}' 執行成功, Status code: ${response.status}`);
        formContext.data.refresh(true); // 重新整理頁面
        console.log("頁面已重新整理");
    } else {
        const error = await response.json();
        console.log(`Action '${actionName}' 執行失敗, Status code: ${response.status}`, error);
    }
}
// #endregion
```

**JavaScript 主要邏輯與改進：**

- **`_enable` 函數：** 檢查表單狀態 (`formContext.ui.getFormType() === 2` 確保記錄已儲存) 和任務狀態 (`theo_taskstatus`) 來決定按鈕是否可用。
- **`Assign_action` 函數：** 在呼叫後端前，增加前端驗證，確保「項目負責人」(`theo_taskowner`) 欄位已被填寫。
- **`callSetStatusAction` (共用函數)：**
    - 處理所有按鈕呼叫後端 `theo_SetDevelopmentTaskStatus` Action 的邏輯。
    - 檢查記錄是否已儲存 (`recordId` 是否存在)。
    - 正確構建 `Xrm.WebApi.online.execute` 所需的 `request` 物件 (包含 `Operation` 和 `Target` 參數)。
    - 使用 `async/await` 處理非同步操作。
    - **（已加入改進）** 使用 `try...catch...finally` 進行錯誤處理。
    - **（已加入改進）** 使用 `Xrm.Utility.showProgressIndicator` / `closeProgressIndicator` 提供使用者操作反饋。
    - **（已加入改進）** 使用 `Xrm.Navigation.openAlertDialog` 或 `openErrorDialog` 向使用者顯示必要的提示或錯誤訊息。
    - 成功後使用 `formContext.data.refresh(true)` 刷新頁面。

### 2. Plugin (SetDevelopmentTaskStatusPlugin) 詳解

處理 `theo_SetDevelopmentTaskStatus` Action 的後端邏輯。

C#

```
// --- 省略 using 和 class/method 定義 ---
// --- 省略取得 context, service, tracer 的標準代碼 ---

public void Execute(IServiceProvider serviceProvider)
{
    // ... 取得 context, service, tracer ...

    // 欄位與選項集常數 (建議定義為常數)
    const string statusField = "theo_taskstatus";
    const string assignTimeField = "theo_assigntime";
    const string deliverTimeField = "theo_delivertime";
    const string closeTimeField = "theo_closetime";
    const string rejectActionName = "theo_SetRejectSetting"; // 要呼叫的 Action 名稱
    const int developmentValue = 638540001;
    const int pendingValue = 638540002;
    const int closedValue = 638540003;

    try
    {
        // 讀取輸入參數
        string operation = context.InputParameters["Operation"] as string;
        EntityReference targetRef = context.InputParameters["Target"] as EntityReference;

        if (string.IsNullOrEmpty(operation) || targetRef == null)
        {
            throw new InvalidPluginExecutionException("輸入參數 Operation 或 Target 缺失。");
        }

        tracer.Trace(<span class="math-inline">"開始處理 Operation\: \{operation\} for Target\: \{targetRef\.Id\}"\);
// 準備更新物件
Entity taskToUpdate \= new Entity\(targetRef\.LogicalName, targetRef\.Id\);
DateTime currentTime \= DateTime\.UtcNow;
// 根據 Operation 執行不同邏輯
switch \(operation\)
\{
case "Assign"\:
tracer\.Trace\("執行 Assign 操作"\);
taskToUpdate\[statusField\] \= new OptionSetValue\(developmentValue\); // 開發中
taskToUpdate\[assignTimeField\] \= currentTime;
service\.Update\(taskToUpdate\);
tracer\.Trace\("狀態更新為「開發中」，記錄「交派時間」。"\);
break;
case "DevDone"\:
tracer\.Trace\("執行 DevDone 操作"\);
taskToUpdate\[statusField\] \= new OptionSetValue\(pendingValue\); // 待審核
taskToUpdate\[deliverTimeField\] \= currentTime;
service\.Update\(taskToUpdate\);
tracer\.Trace\("狀態更新為「待審核」，記錄「交付時間」。"\);
break;
case "Approve"\:
tracer\.Trace\("執行 Approve 操作"\);
taskToUpdate\[statusField\] \= new OptionSetValue\(closedValue\); // 結案
taskToUpdate\[closeTimeField\] \= currentTime;
service\.Update\(taskToUpdate\);
tracer\.Trace\("狀態更新為「結案」，記錄「結案時間」。"\);
break;
case "Reject"\:
tracer\.Trace\("執行 Reject 操作，觸發 " \+ rejectActionName\);
// 建立請求以呼叫另一個 Action
OrganizationRequest rejectRequest \= new OrganizationRequest\(rejectActionName\);
rejectRequest\["Target"\] \= targetRef; // 將目標傳遞給下一個 Action
// 執行 Action
service\.Execute\(rejectRequest\);
tracer\.Trace\(</span>"已觸發 Action: {rejectActionName}");
                break;

            default:
                tracer.Trace(<span class="math-inline">"未知的操作\: \{operation\}"\);
throw new InvalidPluginExecutionException\(</span>"不支援的操作類型: {operation}");
        }
        tracer.Trace("SetDevelopmentTaskStatusPlugin 執行完畢");
    }
    catch (Exception ex)
    {
        tracer.Trace(<span class="math-inline">"SetDevelopmentTaskStatusPlugin Error\: \{ex\.ToString\(\)\}"\);
// 將錯誤拋出給平台，以便前端能收到失敗訊息並可能回復交易
throw new InvalidPluginExecutionException\(</span>"執行 SetDevelopmentTaskStatus 時發生錯誤: {ex.Message}", ex);
    }
}
```

**Plugin 主要邏輯：**

- 接收 `Operation` 和 `Target` 輸入參數。
- 使用 `switch` 語句根據 `Operation` 的值執行不同操作：
    - **Assign, DevDone, Approve:** 建立一個 `Entity` 物件 (`taskToUpdate`)，設定要更新的狀態 (`OptionSetValue`) 和對應的時間戳 (`DateTime.UtcNow`)，然後呼叫 `service.Update()`。
    - **Reject:** 建立一個 `OrganizationRequest` 物件，指定要呼叫的 Action 名稱 (`theo_SetRejectSetting`)，將 `Target` 作為參數傳遞，並呼叫 `service.Execute()` 來觸發另一個 Plugin (`SetRejectSettingPlugin`) 執行後續的退回邏輯。
- **（已加入改進）** 在 `catch` 區塊中記錄錯誤並使用 `throw new InvalidPluginExecutionException` 將錯誤拋回給平台，確保前端能收到錯誤回饋且交易能正確回復。
- **（已加入改進）** 在 `default` 情況下也拋出錯誤，處理未知的 `Operation` 值。

### 3. Plugin (SetRejectSettingPlugin) 詳解

處理 `theo_SetRejectSetting` Action，負責退回操作的資料更新。

C#

```
// --- 省略 using 和 class/method 定義 ---
// --- 省略取得 context, service, tracer 的標準代碼 ---

public void Execute(IServiceProvider serviceProvider)
{
    // ... 取得 context, service, tracer ...

    // 欄位邏輯名稱常數
    const string rejectCountField = "theo_rejectcount";
    const string taskOwnerField = "theo_taskowner";
    const string deliverTimeField = "theo_delivertime";
    const string employeeTaskRejectCountField = "theo_taskrejectcount";

    try
    {
        tracer.Trace("SetRejectSettingPlugin 開始執行");

        // 1. 驗證並獲取輸入 Target
        if (!context.InputParameters.Contains("Target") || !(context.InputParameters["Target"] is EntityReference))
        {
            throw new InvalidPluginExecutionException("輸入參數缺少 Target (EntityReference)。");
        }
        EntityReference targetRef = (EntityReference)context.InputParameters["Target"];
        tracer.Trace(<span class="math-inline">"收到的 Target\: Entity\=\{targetRef\.LogicalName\}, ID\=\{targetRef\.Id\}"\);
// 2\. 查詢 DevelopmentTask \(僅需必要欄位\)
tracer\.Trace\(</span>"查詢 {targetRef.LogicalName} ID {targetRef.Id} 的 {rejectCountField} 和 {taskOwnerField}");
        Entity retrievedTask = service.Retrieve(targetRef.LogicalName, targetRef.Id,
            new ColumnSet(rejectCountField, taskOwnerField));

        // 3. 更新 DevelopmentTask：清空交付時間 & 增加退件次數
        Entity taskToUpdate = new Entity(targetRef.LogicalName, targetRef.Id);
        taskToUpdate[deliverTimeField] = null; // 清空
        int currentRejectCount = retrievedTask.Contains(rejectCountField) ? retrievedTask.GetAttributeValue<int>(rejectCountField) : 0;
        taskToUpdate[rejectCountField] = currentRejectCount + 1; // 次數+1
        tracer.Trace(<span class="math-inline">"準備更新 Task\: 清空 \{deliverTimeField\}, 設定 \{rejectCountField\} 為 \{currentRejectCount \+ 1\}"\);
service\.Update\(taskToUpdate\);
tracer\.Trace\(</span>"已更新 {targetRef.LogicalName} ID {targetRef.Id}");

        // 4. 更新相關員工的退件數 (如果存在負責人)
        if (retrievedTask.Contains(taskOwnerField) && retrievedTask.GetAttributeValue<EntityReference>(taskOwnerField) != null)
        {
            EntityReference employeeRef = retrievedTask.GetAttributeValue<EntityReference>(taskOwnerField);
            tracer.Trace(<span class="math-inline">"找到項目負責人\: \{employeeRef\.LogicalName\} ID \{employeeRef\.Id\}"\);
// 查詢員工的目前退件數
tracer\.Trace\(</span>"查詢 {employeeRef.LogicalName} ID {employeeRef.Id} 的 {employeeTaskRejectCountField}");
            Entity retrievedEmployee = service.Retrieve(employeeRef.LogicalName, employeeRef.Id,
                new ColumnSet(employeeTaskRejectCountField));

            // 準備更新員工
            Entity employeeToUpdate = new Entity(employeeRef.LogicalName, employeeRef.Id);
            int currentEmployeeRejectCount = retrievedEmployee.Contains(employeeTaskRejectCountField) ? retrievedEmployee.GetAttributeValue<int>(employeeTaskRejectCountField) : 0;
            employeeToUpdate[employeeTaskRejectCountField] = currentEmployeeRejectCount + 1; // 次數+1
            tracer.Trace(<span class="math-inline">"準備更新員工 \{employeeTaskRejectCountField\} 為 \{currentEmployeeRejectCount \+ 1\}"\);
service\.Update\(employeeToUpdate\);
tracer\.Trace\(</span>"已更新員工 {employeeRef.LogicalName} ID {employeeRef.Id}");
        }
        else
        {
            tracer.Trace(<span class="math-inline">"警告：找不到項目負責人 \(\{taskOwnerField\}\)，無法更新員工退件數。"\);
\}
tracer\.Trace\("SetRejectSettingPlugin 執行完畢"\);
\}
catch \(Exception ex\)
\{
tracer\.Trace\(</span>"SetRejectSettingPlugin Error: {ex.ToString()}");
        // **重要：** 將錯誤拋回給平台
        throw new InvalidPluginExecutionException($"執行 SetRejectSetting 時發生錯誤: {ex.Message}", ex);
    }
}
```

**`SetRejectSettingPlugin` 主要邏輯與改進：**

- 獲取傳入的 `Target` (Development Task 的參照)。
- 查詢該 Development Task 的目前退件次數和負責人。
- 更新 Development Task：將交付時間設為 `null`，並將退件次數加 1。
- **（已加入改進）** 檢查負責人欄位是否存在且有值。
- 如果負責人存在，查詢該負責人（員工）的目前「開發項目退件數」。
- 更新員工記錄，將其「開發項目退件數」加 1。
- **（已加入改進）** 使用 `Contains()` 檢查欄位是否存在，避免直接取值出錯。
- **（已加入改進）** 在 `catch` 中拋出 `InvalidPluginExecutionException`，確保錯誤能被平台捕獲並傳遞。

---

## 相關核心概念：Custom API 與資料型別

(此部分為理解本實作的背景知識)

- **Custom API (自訂 API):** 封裝業務邏輯供重複呼叫，具明確輸入/輸出參數及型別。
- **資料型別:** 需理解基礎型別 (`String`, `Int`, `DateTime`...) 及 Dynamics 特定型別 (`Entity`, `EntityReference`, `OptionSetValue`...) 在 JavaScript (EDM) 和 C# 中的對應與處理。
- **`Xrm.WebApi.online.execute`:** 前端呼叫 Action/Function 的核心方法，需構建包含參數和 `getMetadata` 的 `request`。
- **Plugin 參數:** `context.InputParameters` / `context.OutputParameters` 存取參數，需進行型別轉換。
- **`Xrm.WebApi.retrieveMultipleRecords`:** 前端查詢多筆記錄，使用 OData 或 FetchXML，需處理分頁。

---

## 實作流程總結

1. **使用者點擊按鈕** -> 觸發 **JS `_enable`** 檢查 -> 若啟用，觸發 **JS `_action`**。
2. `_action` 執行前端驗證 (如檢查負責人)。
3. `_action` 呼叫共用 **JS `callSetStatusAction`** (傳入操作類型)。
4. `callSetStatusAction` 顯示進度提示，構建 `request`，呼叫 **`Xrm.WebApi.online.execute`** 觸發後端 **`theo_SetDevelopmentTaskStatus` Action**。
5. 平台觸發 **`SetDevelopmentTaskStatusPlugin`**。
6. Plugin 根據 `Operation`：
    - **Assign/DevDone/Approve:** 呼叫 `service.Update()` 更新狀態/時間。
    - **Reject:** 呼叫 `service.Execute()` 觸發 **`theo_SetRejectSetting` Action**。
7. (若為 Reject) 平台觸發 **`SetRejectSettingPlugin`**。
8. `SetRejectSettingPlugin` 執行清空時間、增加計數等更新操作 (`service.Update`)。
9. Plugin 成功執行或拋出錯誤。
10. **`Xrm.WebApi.online.execute`** 返回成功或失敗回應。
11. `callSetStatusAction` 根據回應：刷新頁面 (成功) 或顯示錯誤彈窗 (失敗)。
12. 關閉進度提示。